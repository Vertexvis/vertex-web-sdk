/* eslint-disable */
/* tslint:disable */
/**
 * This is an autogenerated file created by the Stencil compiler.
 * It contains typing information for all components that exist in this project.
 */
import { HTMLStencilElement, JSXBase } from '@stencil/core/internal';
import {
  RowArg,
  RowDataProvider,
  ScrollToOptions,
  SelectItemOptions,
} from './components/scene-tree/scene-tree';
import { Config } from './lib/config';
import { Environment } from './lib/environment';
import {
  FilterTreeOptions,
  SceneTreeController,
} from './components/scene-tree/lib/controller';
import { MetadataKey } from './components/scene-tree/interfaces';
import { SceneTreeErrorDetails } from './components/scene-tree/lib/errors';
import { Row } from './components/scene-tree/lib/row';
import { Node } from '@vertexvis/scene-tree-protos/scenetree/protos/domain_pb';
import { SceneTreeTableCellEventDetails } from './components/scene-tree-table-cell/scene-tree-table-cell';
import { RowDataProvider as RowDataProvider1 } from './components/scene-tree/scene-tree';
import { DomScrollToOptions } from './components/scene-tree-table-layout/lib/dom';
import { FrameCameraType } from './lib/types/frameCamera';
import {
  FeatureHighlightOptions,
  FeatureLineOptions,
  FrameType,
} from './interfaces';
import { ColorMaterial } from './lib/scenes/colorMaterial';
import { Frame, FrameCameraBase } from './lib/types/frame';
import { ViewerStream } from './lib/stream/stream';
import {
  AngleUnitType,
  DepthBuffer,
  DistanceUnitType,
  EntityType,
  FrameCameraBase as FrameCameraBase1,
  FramePerspectiveCamera,
  Measurement,
  Orientation,
  StencilBufferManager,
  Viewport,
} from './lib/types';
import { TapEventDetails } from './lib/interactions/tapEventDetails';
import { ConnectionStatus } from './components/viewer/viewer';
import {
  Dimensions,
  Euler,
  Matrix4,
  Point,
  Quaternion,
  Rectangle,
  Vector3,
} from '@vertexvis/geometry';
import { Disposable } from '@vertexvis/utils';
import { InteractionHandler } from './lib/interactions/interactionHandler';
import { KeyInteraction } from './lib/interactions/keyInteraction';
import { Cursor } from './lib/cursors';
import { BaseInteractionHandler } from './lib/interactions/baseInteractionHandler';
import { Scene } from './lib/scenes/scene';
import { ViewerToolbarPlacement } from './components/viewer-toolbar/viewer-toolbar';
import { ViewerToolbarGroupDirection } from './components/viewer-toolbar-group/viewer-toolbar-group';
import { ViewerDomRendererDrawMode } from './components/viewer-dom-renderer/viewer-dom-renderer';
import {
  ViewerIconName,
  ViewerIconSize,
} from './components/viewer-icon/viewer-icon';
import { ViewerMarkupToolType } from './components/viewer-markup-tool/viewer-markup-tool';
import { Markup } from './lib/types/markup';
import { ViewerMarkupArrowMode } from './components/viewer-markup-arrow/viewer-markup-arrow';
import { ViewerMarkupCircleMode } from './components/viewer-markup-circle/viewer-markup-circle';
import { ViewerMarkupFreeformMode } from './components/viewer-markup-freeform.tsx/viewer-markup-freeform';
import { ViewerMarkupToolType as ViewerMarkupToolType1 } from './components/viewer-markup-tool/viewer-markup-tool';
import {
  MeasurementController,
  MeasurementModel,
  MeasurementOutcome,
  MeasurementOverlayManager,
  MeasurementResult,
} from './lib/measurement';
import { Formatter } from './lib/formatter';
import {
  EditBeginEventDetails,
  EditEndEventDetails,
  ViewerMeasurementDistanceElementMetrics,
  ViewerMeasurementDistanceMode,
} from './components/viewer-measurement-distance/viewer-measurement-distance';
import { Anchor } from './components/viewer-measurement-distance/utils';
import { PointToPointHitProvider } from './components/viewer-measurement-distance/interactions';
import { ViewerMeasurementToolType } from './components/viewer-measurement-tool/viewer-measurement-tool';
import { ViewerMeasurementToolType as ViewerMeasurementToolType1 } from './components/viewer-measurement-tool/viewer-measurement-tool';
import {
  Pin,
  PinModel,
  TextPin,
  ViewerPinToolMode,
  ViewerPinToolType,
} from './lib/pins/model';
import { PinController } from './lib/pins/controller';
import {
  ViewerToolbarDirection,
  ViewerToolbarPlacement as ViewerToolbarPlacement1,
} from './components/viewer-toolbar/viewer-toolbar';
import { ViewerToolbarGroupDirection as ViewerToolbarGroupDirection1 } from './components/viewer-toolbar-group/viewer-toolbar-group';
import { TransformController } from './lib/transforms/controller';
import { Drawable } from './lib/transforms/drawable';
export namespace Components {
  interface VertexSceneTree {
    /**
     * Performs an API call to collapse all nodes in the tree.
     */
    collapseAll: () => Promise<void>;
    /**
     * Performs an API call that will collapse the node associated to the specified row or row index.
     * @param row A row, row index, or node to collapse.
     */
    collapseItem: (row: RowArg) => Promise<void>;
    /**
     * An object to configure the scene tree.
     */
    config?: Config;
    /**
     * Sets the default environment for the viewer. This setting is used for auto-configuring network hosts.  Use the `config` property for manually setting hosts.
     */
    configEnv: Environment;
    controller?: SceneTreeController;
    /**
     * Performs an API call that will deselect the item associated to the given row or row index.
     * @param row The row, row index, or node to deselect.
     */
    deselectItem: (row: RowArg) => Promise<void>;
    /**
     * Performs an API call to expand all nodes in the tree.
     */
    expandAll: () => Promise<void>;
    /**
     * Performs an API call that will expand the node associated to the specified row or row index.
     * @param row A row, row index, or node to expand.
     */
    expandItem: (row: RowArg) => Promise<void>;
    /**
     * Fetches the metadata keys that are available to the scene tree. Metadata keys can be assigned to the scene tree using the `metadataKeys` property. The scene tree will fetch this metadata and make these values available for data binding.
     * @returns A promise that resolves with the names of available keys.
     */
    fetchMetadataKeys: () => Promise<MetadataKey[]>;
    /**
     * Performs an async request that will filter the displayed items in the tree that match the given term and options.
     * @param term The filter term.
     * @param options The options to apply to the filter.
     * @returns A promise that completes when the request has completed. Note, items are displayed asynchronously. So the displayed items may not reflect the result of this filter when the promise completes.
     */
    filterItems: (term: string, options?: FilterTreeOptions) => Promise<void>;
    /**
     * Returns the row data from the given vertical client position.
     * @param clientY The vertical client position.
     * @returns A row or `undefined` if the row hasn't been loaded.
     */
    getRowAtClientY: (clientY: number) => Promise<Row>;
    /**
     * Returns a row at the given index. If the row data has not been loaded, returns `undefined`.
     * @param index The index of the row.
     * @returns A row, or `undefined` if the row hasn't been loaded.
     */
    getRowAtIndex: (index: number) => Promise<Row>;
    /**
     * Returns the row data from the given mouse or pointer event. The event must originate from a `vertex-scene-tree-table-cell` contained by this element, otherwise `undefined` is returned.
     * @param event A mouse or pointer event that originated from this component.
     * @returns A row, or `undefined` if the row hasn't been loaded.
     */
    getRowForEvent: (event: MouseEvent | PointerEvent) => Promise<Row>;
    /**
     * Performs an API call that will hide the item associated to the given row or row index.
     * @param row The row, row index, or node to hide.
     */
    hideItem: (row: RowArg) => Promise<void>;
    /**
     * Schedules a render of the rows in the scene tree. Useful if any custom data in your scene tree has changed, and you want to update the row's contents.  **Note:** This is an asynchronous operation. The update may happen on the next frame.
     */
    invalidateRows: () => Promise<void>;
    /**
     * A list of part metadata keys that will be made available to each row. This metadata can be used for data binding inside the scene tree's template.
     */
    metadataKeys: MetadataKey[];
    /**
     * Indicates whether the metadata search should use an exact match.
     */
    metadataSearchExactMatch: boolean;
    /**
     * A list of the metadata keys that a scene tree search should be performed on.
     */
    metadataSearchKeys: MetadataKey[];
    /**
     * The number of offscreen rows above and below the viewport to render. Having a higher number reduces the chance of the browser not displaying a row while scrolling.
     */
    overScanCount: number;
    /**
     * A callback that is invoked immediately before a row is about to rendered. This callback can return additional data that can be bound to in a template.
     * @example ```html <script>   const table = document.querySelector('vertex-scene-tree-table');   table.rowData = (row) => {     return { func: () => console.log('row', row.node.name) };   } </script>  <vertex-scene-tree>  <vertex-scene-tree-table>    <vertex-scene-tree-table-column>      <template>        <button event:click="{{row.data.func}}">Hi</button>      </template>    </vertex-scene-tree-table-column>  </vertex-scene-tree-table> </vertex-scene-tree> ```
     */
    rowData?: RowDataProvider;
    /**
     * Scrolls the tree to the given row index.
     * @param index An index of the row to scroll to.
     * @param options A set of options to configure the scrolling behavior.
     */
    scrollToIndex: (index: number, options?: ScrollToOptions) => Promise<void>;
    /**
     * Scrolls the tree to an item with the given ID. If the node for the item is not expanded, the tree will expand each of its parent nodes.
     * @param itemId An ID of an item to scroll to.
     * @param options A set of options to configure the scrolling behavior.
     * @returns A promise that resolves when the operation is finished.
     */
    scrollToItem: (itemId: string, options?: ScrollToOptions) => Promise<void>;
    /**
     * Performs an async request that will select the filtered items in the tree that match the given term.
     * @param term The filter term.
     * @returns A promise that completes when the request has completed.
     */
    selectFilteredItems: (term: string) => Promise<void>;
    /**
     * Performs an API call that will select the item associated to the given row or row index.  This method supports a `recurseParent` option that allows for recursively selecting the next unselected parent node. This behavior is considered stateful. Each call to `selectItem` will track the ancestry of the passed in `rowArg`. If calling `selectItem` with a row not belonging to the ancestry of a previous selection, then this method will perform a standard selection.
     * @param row The row, row index or node to select.
     * @param options A set of options to configure selection behavior.
     */
    selectItem: (
      row: RowArg,
      { recurseParent, ...options }?: SelectItemOptions
    ) => Promise<void>;
    /**
     * Performs an API call that will show the item associated to the given row or row index.
     * @param row The row, row index, or node to show.
     */
    showItem: (row: RowArg) => Promise<void>;
    /**
     * Performs an API call that will either expand or collapse the node associated to the given row or row index.
     * @param row The row, row index, or node to collapse or expand.
     */
    toggleExpandItem: (row: RowArg) => Promise<void>;
    /**
     * Performs an API call that will either hide or show the item associated to the given row or row index.
     * @param row The row, row index, or node to toggle visibility.
     */
    toggleItemVisibility: (row: RowArg) => Promise<void>;
    /**
     * An instance of a `<vertex-viewer>` element. Either this property or `viewerSelector` must be set.
     */
    viewer?: HTMLVertexViewerElement | null;
    /**
     * A CSS selector that points to a `<vertex-viewer>` element. Either this property or `viewer` must be set.
     */
    viewerSelector?: string;
  }
  interface VertexSceneTreeSearch {
    /**
     * Specifies the delay, in milliseconds, to emit `search` events after user input.
     */
    debounce: number;
    /**
     * If `true`, disables user interaction of the component.
     */
    disabled: boolean;
    /**
     * Placeholder text if `value` is empty.
     */
    placeholder?: string;
    /**
     * Gives focus to the the component's internal text input.
     */
    setFocus: () => Promise<void>;
    /**
     * The current text value of the component. Value is updated on user interaction.
     */
    value: string;
  }
  interface VertexSceneTreeTableCell {
    /**
     * Indicates whether to display a button for toggling the expanded state of the node associated with this cell.
     */
    expandToggle?: boolean;
    hoveredNodeId?: string;
    /**
     * A flag that disables the default interactions of this component. If disabled, you can use the event handlers to be notified when certain operations are performed by the user.
     */
    interactionsDisabled: boolean;
    isScrolling?: boolean;
    /**
     * The node data that is associated to the row that this cell belongs to. Contains information related to if the node is expanded, visible, etc.
     */
    node?: Node.AsObject;
    /**
     * The value to display in this cell if the `value` specified is undefined. Defaults to "--".
     */
    placeholder: string;
    /**
     * A flag that disables selection of the node's parent if the user selects the row multiple times. When enabled, selection of the same row multiple times will recursively select the next unselected parent until the root node is selected.
     */
    recurseParentSelectionDisabled: boolean;
    /**
     * A reference to the scene tree to perform operations for interactions. Such as expansion, visibility and selection.
     */
    tree?: HTMLVertexSceneTreeElement;
    /**
     * The value to display in this cell.
     */
    value?: string;
    /**
     * Indicates whether to display a button for toggling the visibility state of the node associated with this cell.
     */
    visibilityToggle?: boolean;
  }
  interface VertexSceneTreeTableColumn {
    /**
     * The initial width of this column.
     */
    initialWidth?: number;
    /**
     * The maximum width of this column.
     */
    maxWidth?: number;
    /**
     * The minimum width of this column.
     */
    minWidth?: number;
  }
  interface VertexSceneTreeTableHeader {}
  interface VertexSceneTreeTableLayout {
    controller?: SceneTreeController;
    layoutHeight?: number;
    layoutOffset: number;
    layoutWidth?: number;
    /**
     * The number of offscreen rows above and below the viewport to render. Having a higher number reduces the chance of the browser not displaying a row while scrolling.  This prop will be automatically populated based on the `overScanCount` prop specified in the parent `<vertex-scene-tree />` element.
     */
    overScanCount: number;
    /**
     * A callback that is invoked immediately before a row is about to rendered. This callback can return additional data that can be bound to in a template.  This prop will be automatically populated based on the `rowData` prop specified in the parent `<vertex-scene-tree />` element.
     * @example ```html <script>   const table = document.querySelector('vertex-scene-tree-table');   table.rowData = (row) => {     return { func: () => console.log('row', row.node.name) };   } </script>  <vertex-scene-tree>  <vertex-scene-tree-table>    <vertex-scene-tree-table-column>      <template>        <button event:click="{{row.data.func}}">Hi</button>      </template>    </vertex-scene-tree-table-column>  </vertex-scene-tree-table> </vertex-scene-tree> ```
     */
    rowData?: RowDataProvider;
    rowHeight: number;
    rows: Row[];
    scrollOffset: number;
    /**
     * Scrolls the table to the provided top value.
     * @param top The position to scroll to.
     * @param options A set of options to configure the scrolling behavior.
     */
    scrollToPosition: (
      top: number,
      options: Pick<DomScrollToOptions, 'behavior'>
    ) => Promise<void>;
    totalRows: number;
    /**
     * A reference to the scene tree to perform operations for interactions. Such as expansion, visibility and selection.
     */
    tree?: HTMLVertexSceneTreeElement;
    viewportEndIndex: number;
    viewportStartIndex: number;
  }
  interface VertexSceneTreeTableResizeDivider {}
  interface VertexSceneTreeToolbar {}
  interface VertexSceneTreeToolbarGroup {}
  interface VertexViewer {
    /**
     * Adds a cursor to the viewer, and displays it if the cursor has the highest priority.  Cursors are managed as a prioritized list. A cursor is displayed if it has the highest priority or if the cursor is the most recently added cursor in the set of cursors with the same priority.  To remove a cursor, call `dispose()` on the returned disposable.
     * @param cursor The cursor to add.
     * @param priority The priority of the cursor.
     * @returns A disposable that can be used to remove the cursor.
     * @see See {@link CursorManager} for constants to pass to `priority`.
     */
    addCursor: (
      cursor: Cursor,
      priority?: number | undefined
    ) => Promise<Disposable>;
    /**
     * Enables or disables the default mouse and touch interactions provided by the viewer. Enabled by default.
     */
    cameraControls: boolean;
    /**
     * The type of camera model to represent the scene with. Can be either `perspective` or `orthographic`, and defaults to `perspective`.
     */
    cameraType: FrameCameraType;
    /**
     * The Client ID associated with your Vertex Application.
     */
    clientId?: string;
    /**
     * An object or JSON encoded string that defines configuration settings for the viewer.
     */
    config?: Config | string;
    /**
     * Sets the default environment for the viewer. This setting is used for auto-configuring network hosts.  Use the `config` property for manually setting hosts.
     * @see Viewer.config
     */
    configEnv: Environment;
    /**
     * Specifies when a depth buffer is requested from rendering. Possible values are:  * `undefined`: A depth buffer is never requested. * `final`: A depth buffer is only requested on the final frame. * `all`: A depth buffer is requested for every frame.  Depth buffers can increase the amount of data that's sent to a client and can impact rendering performance. Values of `undefined` or `final` should be used when needing the highest rendering performance.
     */
    depthBuffers?: FrameType;
    /**
     * Property used for internals or testing.
     * @private
     */
    deviceId?: string;
    dispatchFrameDrawn: (frame: Frame) => Promise<void>;
    /**
     * Specifies the opacity, between 0 and 100, for an experimental ghosting feature. When the value is non-zero, any scene items that are hidden will be appear translucent.  **Note:** This feature is experimental, and may cause slower frame rates.
     */
    experimentalGhostingOpacity: number;
    /**
     * Specifies how selected features should be highlighted.
     */
    featureHighlighting?: FeatureHighlightOptions;
    /**
     * Specifies if and how to render feature lines.
     */
    featureLines?: FeatureLineOptions;
    /**
     * Specifies when a feature map is returned from rendering. Feature maps include information about the surfaces, edges and cross sections that are in a frame.  Possible values are:  * `undefined`: A feature map is never requested. * `final`: A feature map is only requested on the final frame. * `all`: A feature map is requested for every frame.  Feature maps can increase the amount of data that's sent to a client and can impact rendering performance. Values of `undefined` or `final` should be used when needing the highest rendering performance.
     */
    featureMaps?: FrameType;
    /**
     * The last frame that was received, which can be used to inspect the scene and camera information.
     * @readonly
     */
    frame: Frame | undefined;
    getBaseInteractionHandler: () => Promise<
      BaseInteractionHandler | undefined
    >;
    getInteractionHandlers: () => Promise<InteractionHandler[]>;
    /**
     * The HTML element that will handle interaction events from the user. Used by components to listen for interaction events from the same element as the viewer. Note, this property maybe removed in the future when refactoring our interaction handling.
     */
    getInteractionTarget: () => Promise<HTMLElement>;
    /**
     * @deprecated Use `token`.
     */
    getJwt: () => Promise<string | undefined>;
    /**
     * Returns `true` indicating that the scene is ready to be interacted with.
     */
    isSceneReady: () => Promise<boolean>;
    /**
     * Enables or disables the default keyboard shortcut interactions provided by the viewer. Enabled by default, requires `cameraControls` being enabled.
     */
    keyboardControls: boolean;
    /**
     * Loads the given scene into the viewer and return a `Promise` that resolves when the scene has been loaded. The specified scene is provided as a URN in the following format:   * `urn:vertexvis:scene:<sceneid>`
     * @param urn The URN of the resource to load.
     */
    load: (urn: string) => Promise<void>;
    /**
     * Specifies whether to use the default lights for the scene. When false, default lights are used. When true, no default lights are used, and the lights must be specified separately.
     */
    noDefaultLights: boolean;
    /**
     * Registers and initializes an interaction handler with the viewer. Returns a `Disposable` that should be used to deregister the interaction handler.  `InteractionHandler`s are used to build custom mouse and touch interactions for the viewer. Use `<vertex-viewer camera-controls="false" />` to disable the default camera controls provided by the viewer.
     * @example
     * ```
     * class CustomInteractionHandler extends InteractionHandler {
     *   private element: HTMLElement;
     *   private api: InteractionApi;
     *   public dispose(): void {
     *     this.element.removeEventListener('click', this.handleElementClick);
     *   }
     *   public initialize(element: HTMLElement, api: InteractionApi): void {
     *     this.api = api;
     *     this.element = element;
     *     this.element.addEventListener('click', this.handleElementClick);
     *   }
     *   private handleElementClick = (event: MouseEvent) => {
     *     api.tap({ x: event.clientX, y: event.clientY });
     *   };
     * }
     * const viewer = document.querySelector('vertex-viewer');
     * viewer.registerInteractionHandler(new CustomInteractionHandler());
     * ```
     * @param interactionHandler The interaction handler to register.
     * @returns A promise containing the disposable to use to deregister the handler.
     */
    registerInteractionHandler: (
      interactionHandler: InteractionHandler
    ) => Promise<Disposable>;
    /**
     * Registers a key interaction to be invoked when a specific set of keys are pressed during a `tap` event.  `KeyInteraction`s are used to build custom keyboard shortcuts for the viewer using the current state of they keyboard to determine whether the `fn` should be invoked. Use `<vertex-viewer keyboard-controls="false" />` to disable the default keyboard shortcuts provided by the viewer.
     * @example
     * ```
     * class CustomKeyboardInteraction extends KeyInteraction<TapEventDetails> {
     *   constructor(private viewer: HTMLVertexViewerElement) {}
     *   public predicate(keyState: KeyState): boolean {
     *     return keyState['Alt'];
     *   }
     *   public async fn(event: TapEventDetails) {
     *     const scene = await this.viewer.scene();
     *     const result = await scene.raycaster().hitItems(event.position);
     *     if (result.hits.length > 0) {
     *       await scene
     *         .camera()
     *         .fitTo((q) => q.withItemId(result.hits[0].itemId))
     *         .render();
     *     }
     *   }
     * }
     * ```
     * @param keyInteraction - The `KeyInteraction` to register.
     */
    registerTapKeyInteraction: (
      keyInteraction: KeyInteraction<TapEventDetails>
    ) => Promise<void>;
    /**
     * An optional value that will debounce frame updates when resizing this viewer element.
     */
    resizeDebounce: number;
    resolvedConfig?: Config;
    /**
     * Enables or disables the default rotation interaction being changed to rotate around the pointer down location.
     */
    rotateAroundTapPoint: boolean;
    /**
     * Returns an object that is used to perform operations on the `Scene` that's currently being viewed. These operations include updating items, positioning the camera and performing hit tests.
     */
    scene: () => Promise<Scene>;
    /**
     * The default hex color or material to use when selecting items.
     */
    selectionMaterial: string | ColorMaterial;
    /**
     * A URN of the scene resource to load when the component is mounted in the DOM tree. The specified resource is a URN in the following format:   * `urn:vertexvis:scene:<sceneid>`
     */
    src?: string;
    stencilBuffer: StencilBufferManager;
    stream?: ViewerStream;
    /**
     * A token that can be used to make API calls to other Vertex services.
     */
    token?: string;
    /**
     * Disconnects the websocket and removes any internal state associated with the scene.
     */
    unload: () => Promise<void>;
    /**
     * Represents the current viewport of the viewer. The viewport represents the dimensions of the canvas where a frame is rendered. It contains methods for translating between viewport coordinates, frame coordinates and world coordinates.
     */
    viewport: Viewport;
  }
  interface VertexViewerButton {}
  interface VertexViewerDefaultToolbar {
    /**
     * The duration of animations, in milliseconds. Defaults to `1000`.
     */
    animationMs: number;
    /**
     * Indicates whether animations will be used when performing camera operations. Defaults to `true`.
     */
    animationsDisabled: boolean;
    /**
     * Specifies the direction that UI elements are placed.
     */
    direction: ViewerToolbarGroupDirection;
    /**
     * Specifies where the toolbar is positioned.
     */
    placement: ViewerToolbarPlacement;
    /**
     * An instance of the viewer that operations will be performed on. If contained within a `<vertex-viewer>` element, this property will automatically be wired.
     */
    viewer?: HTMLVertexViewerElement;
  }
  interface VertexViewerDomElement {
    /**
     * Disables the billboarding behavior of the element. When billboarding is enabled, the element will always be oriented towards the screen.
     */
    billboardOff: boolean;
    /**
     * Disables interaction events from children.
     */
    interactionsOff: boolean;
    /**
     * The local matrix of this element.
     */
    matrix: Matrix4.Matrix4;
    /**
     * Indicates if the element is hidden by geometry. This property can be used with a CSS selector to modify the appearance of the element when its occluded.
     * @example ```html <style>   vertex-viewer-dom-element[occluded] {     opacity: 0;   } </style> ```
     */
    occluded: boolean;
    /**
     * Disables occlusion testing for this element. Defaults to enabled. When enabled, the elements position will be tested against the current depth buffer. If the position is occluded, then the `occluded` attribute will be set.
     */
    occlusionOff: boolean;
    /**
     * The local 3D position of where this element is located.
     */
    position: Vector3.Vector3;
    /**
     * The local 3D position of where this element is located, as a JSON string. JSON representation can either be in the format of `[x, y, z]` or `{"x": 0, "y": 0, "z": 0}`.
     */
    positionJson: string;
    /**
     * The local rotation of this element.
     */
    quaternion: Quaternion.Quaternion;
    /**
     * The local quaternion rotation of this element, as a JSON string. JSON representation can either be `[x, y, z, w]` or `{"x": 0, "y": 0, "z": 0, "w": 1}`.
     */
    quaternionJson: string;
    /**
     * The local rotation of this element in Euler angles.
     */
    rotation?: Euler.Euler;
    /**
     * The local rotation of this element in Euler angles, as a JSON string. JSON representation can either be `[x, y, z, order]` or `{"x": 0, "y": 0, "z": 0, "order": "xyz"}`.
     */
    rotationJson?: string;
    /**
     * The local scale of this element.
     */
    scale: Vector3.Vector3;
    /**
     * The local scale of this element, as a JSON string. JSON string representation can either be in the format of `[x, y, z]` or `{"x": 0, "y": 0, "z": 0}`.
     */
    scaleJson: string;
  }
  interface VertexViewerDomGroup {
    /**
     * The local matrix of this element.
     */
    matrix: Matrix4.Matrix4;
    /**
     * The local 3D position of where this element is located.
     */
    position: Vector3.Vector3;
    /**
     * The local 3D position of where this element is located, as a JSON string. JSON representation can either be in the format of `[x, y, z]` or `{"x": 0, "y": 0, "z": 0}`.
     */
    positionJson: string;
    /**
     * The local rotation of this element.
     */
    quaternion: Quaternion.Quaternion;
    /**
     * The local rotation of this element, as a JSON string. JSON representation can either be `[x, y, z, w]` or `{"x": 0, "y": 0, "z": 0, "w": 1}`.
     */
    quaternionJson: string;
    /**
     * The local rotation of this element in Euler angles.
     */
    rotation?: Euler.Euler;
    /**
     * The local rotation of this element in Euler angles, as a JSON string. JSON representation can either be `[x, y, z, order]` or `{"x": 0, "y": 0, "z": 0, "order": "xyz"}`.
     */
    rotationJson?: string;
    /**
     * The local scale of this element.
     */
    scale: Vector3.Vector3;
    /**
     * The local scale of this element, as a JSON string. JSON string representation can either be in the format of `[x, y, z]` or `{"x": 0, "y": 0, "z": 0}`.
     */
    scaleJson: string;
  }
  interface VertexViewerDomRenderer {
    /**
     * The current camera of the frame.  This property will automatically be set when supplying a viewer to the component, or when added as a child to `<vertex-viewer>`.
     */
    camera?: FrameCameraBase;
    /**
     * The current depth buffer of the frame.  This property will automatically be set when supplying a viewer to the component, or when added as a child to `<vertex-viewer>`.
     */
    depthBuffer?: DepthBuffer;
    /**
     * Specifies the drawing mode for the renderer.  When in `3d` mode, elements are positioned using CSS 3D transforms and will scale and rotate with the camera. In `2d` mode, a simpler 2D transform is used, and elements will not scale or rotate with camera changes.
     */
    drawMode: ViewerDomRendererDrawMode;
    /**
     * The viewer synced to this renderer. This property will automatically be assigned if the renderer is a child of `<vertex-viewer>`.
     */
    viewer?: HTMLVertexViewerElement;
  }
  interface VertexViewerIcon {
    /**
     * The name of the icon to render.
     */
    name?: ViewerIconName;
    /**
     * The size of the icon. Can be `'sm' | 'md' | 'lg' | undefined`. Predefined sizes are set to:   * `sm`: 16px  * `md`: 24px  * `lg`: 32px  A custom size can be supplied by setting this field to `undefined` and setting `font-size` through CSS. Defaults to `md`.
     */
    size?: ViewerIconSize;
  }
  interface VertexViewerLayer {
    /**
     * Indicates if the layer should stretch to fill the size of its container's nearest positioned parent.
     */
    stretchOff: boolean;
  }
  interface VertexViewerMarkup {
    /**
     * Adds a new markup as a child to this component. A new markup component will be created from the template specified by `arrow-template-id`, `circle-template-id`, or if undefined a default element will be created.
     * @param markup The markup to add.
     * @returns The markup element that was created.
     * @see {@link ViewerMarkups.arrowTemplateId}
     * @see {@link ViewerMarkups.circleTemplateId}
     */
    addMarkup: (
      markup: Markup
    ) => Promise<
      | HTMLVertexViewerMarkupArrowElement
      | HTMLVertexViewerMarkupCircleElement
      | HTMLVertexViewerMarkupFreeformElement
    >;
    /**
     * An HTML template that describes the HTML to use for new arrow markup. It's expected that the template contains a `<vertex-viewer-markup-arrow>`.
     */
    arrowTemplateId?: string;
    /**
     * An HTML template that describes the HTML to use for new circle markup. It's expected that the template contains a `<vertex-viewer-markup-circle>`.
     */
    circleTemplateId?: string;
    /**
     * If `true`, disables adding or editing of markup through user interaction.
     */
    disabled: boolean;
    /**
     * An HTML template that describes the HTML to use for new freeform markup. It's expected that the template contains a `<vertex-viewer-markup-freeform>`.
     */
    freeformTemplateId?: string;
    /**
     * Returns the markup element associated to the given ID.
     * @param id The ID of the markup element to return.
     * @returns A markup element, or `undefined`.
     * @see {@link ViewerMarkup.getMarkupElements}
     */
    getMarkupElement: (
      id: string
    ) => Promise<
      | HTMLVertexViewerMarkupArrowElement
      | HTMLVertexViewerMarkupCircleElement
      | HTMLVertexViewerMarkupFreeformElement
      | undefined
    >;
    /**
     * Returns a list of markup elements that are children of this component.
     * @returns A list of all markups.
     * @see {@link ViewerMarkup.getMarkupElement}
     */
    getMarkupElements: () => Promise<
      Array<
        | HTMLVertexViewerMarkupArrowElement
        | HTMLVertexViewerMarkupCircleElement
        | HTMLVertexViewerMarkupFreeformElement
      >
    >;
    /**
     * Removes a markup with the given ID, and returns the HTML element associated to the markup. Returns `undefined` if no markup is found.
     * @param id The ID of the markup to remove.
     * @returns The markup element, or undefined.
     */
    removeMarkup: (
      id: string
    ) => Promise<
      | HTMLVertexViewerMarkupArrowElement
      | HTMLVertexViewerMarkupCircleElement
      | HTMLVertexViewerMarkupFreeformElement
      | undefined
    >;
    /**
     * Indicates if new markup should be automatically selected.
     */
    selectNew: boolean;
    /**
     * The ID of the markup that is selected.
     */
    selectedMarkupId?: string;
    /**
     * The type of markup to perform.
     */
    tool: ViewerMarkupToolType;
    /**
     * The viewer to connect to markup. If nested within a <vertex-viewer>, this property will be populated automatically.
     */
    viewer?: HTMLVertexViewerElement;
  }
  interface VertexViewerMarkupArrow {
    dispose: () => Promise<void>;
    /**
     * The position of the ending anchor. Can either be an instance of a `Point` or a JSON string representation in the format of `[x, y]` or `{"x": 0, "y": 0}`.  Points are expected to be relative coordinates from `[-0.5, 0.5]`, e.g. `[0, 0]` corresponds to a point in the center of the viewport.
     */
    end?: Point.Point;
    /**
     * The position of the ending anchor, as a JSON string. Can either be an instance of a `Point` or a JSON string representation in the format of `[x, y]` or `{"x": 0, "y": 0}`.  Points are expected to be relative coordinates from `[-0.5, 0.5]`, e.g. `[0, 0]` corresponds to a point in the center of the viewport.
     */
    endJson?: string;
    /**
     * A mode that specifies how the markup component should behave. When unset, the component will not respond to interactions with the handles. When `edit`, the markup anchors are interactive and the user is able to reposition them. When `create`, anytime the user clicks on the canvas, a new markup will be performed.
     */
    mode: ViewerMarkupArrowMode;
    /**
     * The position of the starting anchor. Can either be an instance of a `Point` or a JSON string representation in the format of `[x, y]` or `{"x": 0, "y": 0}`.  Points are expected to be relative coordinates from `[-0.5, 0.5]`, e.g. `[0, 0]` corresponds to a point in the center of the viewport.
     */
    start?: Point.Point;
    /**
     * The position of the starting anchor, as a JSON string. Can either be an instance of a `Point` or a JSON string representation in the format of `[x, y]` or `{"x": 0, "y": 0}`.  Points are expected to be relative coordinates from `[-0.5, 0.5]`, e.g. `[0, 0]` corresponds to a point in the center of the viewport.
     */
    startJson?: string;
    /**
     * The viewer to connect to markups.  This property will automatically be set when a child of a `<vertex-viewer-markup>` or `<vertex-viewer>` element.
     */
    viewer?: HTMLVertexViewerElement;
  }
  interface VertexViewerMarkupCircle {
    /**
     * The bounds of the circle. Can either be an instance of a `Rectangle` or a JSON string representation in the format of `[x, y, width, height]` or `{"x": 0, "y": 0, "width": 10, "height": 10}`.  Bounds are expected to have relative coordinates, with `[x, y]` from `[-0.5, 0.5]` and `[width, height]` from `[0, 1]`, e.g. `[0, 0, 0.25, 0.25]`corresponds to a circle with a diameter of one fourth the viewport's smallest size in the center of the viewport.
     */
    bounds?: Rectangle.Rectangle;
    /**
     * The bounds of the circle. Can either be an instance of a `Rectangle` or a JSON string representation in the format of `[x, y, width, height]` or `{"x": 0, "y": 0, "width": 0.1, "height": 0.1}`.  Bounds are expected to have relative coordinates, with `[x, y]` from `[-0.5, 0.5]` and `[width, height]` from `[0, 1]`, e.g. `[0, 0, 0.25, 0.25]`corresponds to a circle with a diameter of one fourth the viewport's smallest size in the center of the viewport.
     */
    boundsJson?: string;
    dispose: () => Promise<void>;
    /**
     * A mode that specifies how the markup component should behave. When unset, the component will not respond to interactions with the handles. When `edit`, the markup anchors are interactive and the user is able to reposition them. When `create`, anytime the user clicks on the canvas, a new markup will be performed.
     */
    mode: ViewerMarkupCircleMode;
    /**
     * The viewer to connect to markups.  This property will automatically be set when a child of a `<vertex-viewer-markup>` or `<vertex-viewer>` element.
     */
    viewer?: HTMLVertexViewerElement;
  }
  interface VertexViewerMarkupFreeform {
    /**
     * The bounds of the freeform. Can either be an instance of a `Rectangle` or a JSON string representation in the format of `[x, y, width, height]` or `{"x": 0, "y": 0, "width": 10, "height": 10}`.  Bounds are expected to have relative coordinates, with `[x, y]` from `[-0.5, 0.5]` and `[width, height]` from `[0, 1]`, e.g. `[0, 0, 0.25, 0.25]`corresponds to a freeform with a diameter of one fourth the viewport's smallest size in the center of the viewport.
     */
    bounds?: Rectangle.Rectangle;
    /**
     * The bounds of the freeform. Can either be an instance of a `Rectangle` or a JSON string representation in the format of `[x, y, width, height]` or `{"x": 0, "y": 0, "width": 0.1, "height": 0.1}`.  Bounds are expected to have relative coordinates, with `[x, y]` from `[-0.5, 0.5]` and `[width, height]` from `[0, 1]`, e.g. `[0, 0, 0.25, 0.25]`corresponds to a freeform with a diameter of one fourth the viewport's smallest size in the center of the viewport.
     */
    boundsJson?: string;
    dispose: () => Promise<void>;
    /**
     * A mode that specifies how the markup component should behave. When unset, the component will not respond to interactions with the handles. When `edit`, the markup anchors are interactive and the user is able to reposition them. When `create`, anytime the user clicks on the canvas, a new markup will be performed.
     */
    mode: ViewerMarkupFreeformMode;
    /**
     * The positions of the various points of this freeform markup. Can either be an array of `Point`s or a JSON string representation in the format of `[[x1, y1], [x2, y2]]` or `[{"x": 0, "y": 0}, {"x": 0, "y": 0}]`.  Points are expected to be relative coordinates from `[-0.5, 0.5]`, e.g. `[0, 0]` corresponds to a point in the center of the viewport.
     */
    points?: Point.Point[];
    /**
     * The positions of the various points of this freeform markup. Can either be an array of `Point`s or a JSON string representation in the format of `[[x1, y1], [x2, y2]]` or `[{"x": 0, "y": 0}, {"x": 0, "y": 0}]`.  Points are expected to be relative coordinates from `[-0.5, 0.5]`, e.g. `[0, 0]` corresponds to a point in the center of the viewport.
     */
    pointsJson?: string;
    /**
     * The viewer to connect to markups.  This property will automatically be set when a child of a `<vertex-viewer-markup>` or `<vertex-viewer>` element.
     */
    viewer?: HTMLVertexViewerElement;
  }
  interface VertexViewerMarkupTool {
    /**
     * An HTML template that describes the HTML to use for new arrow markup. It's expected that the template contains a `<vertex-viewer-markup-arrow>`.
     */
    arrowTemplateId?: string;
    /**
     * An HTML template that describes the HTML to use for new circle markup. It's expected that the template contains a `<vertex-viewer-markup-circle>`.
     */
    circleTemplateId?: string;
    /**
     * Disables markups.  This property will automatically be set when a child of a `<vertex-viewer-markup>` element.
     */
    disabled: boolean;
    /**
     * An HTML template that describes the HTML to use for new freeform markup. It's expected that the template contains a `<vertex-viewer-markup-freeform>`.
     */
    freeformTemplateId?: string;
    /**
     * Resets the state of the internally managed markup element to allow for creating a new markup. This state is automatically managed when this element is placed as a child of a `<vertex-viewer-markup>` element.
     */
    reset: () => Promise<void>;
    /**
     * The type of markup.  This property will automatically be set when a child of a `<vertex-viewer-markup>` element.
     */
    tool: ViewerMarkupToolType;
    /**
     * The viewer to connect to markup.  This property will automatically be set when a child of a `<vertex-viewer-markup>` or `<vertex-viewer>` element.
     */
    viewer?: HTMLVertexViewerElement;
  }
  interface VertexViewerMeasurementDetails {
    /**
     * An optional formatter that can be used to format the display of an angle. The formatting function is passed a calculated angle in degrees and is expected to return a string.
     */
    angleFormatter?: Formatter<number>;
    /**
     * The unit of angle-based measurement.
     */
    angleUnits: AngleUnitType;
    /**
     * An optional formatter that can be used to format the display of an area. The formatting function is passed a calculated area and is expected to return a string.
     */
    areaFormatter?: Formatter<number>;
    /**
     * An optional formatter that can be used to format the display of a distance. The formatting function is passed a calculated real-world distance and is expected to return a string.
     */
    distanceFormatter?: Formatter<number>;
    /**
     * The unit of distance-based measurement.
     */
    distanceUnits: DistanceUnitType;
    /**
     * The number of fraction digits to display.
     */
    fractionalDigits: number;
    /**
     * The `MeasurementModel` that should be reflected in these details. If not specified, a new `MeasurementModel` will be created, which can then be used to update the display.
     */
    measurementModel?: MeasurementModel;
    /**
     * The outcome to display. This property is automatically updated if a measurement model is provided.
     */
    measurementOutcome?: MeasurementOutcome;
    /**
     * The manager that the component will use to present measurement overlays.
     */
    measurementOverlays?: MeasurementOverlayManager;
    /**
     * A set of result types to display. If `undefined`, then all results will be displayed.
     */
    resultTypes?: MeasurementResult['type'][];
  }
  interface VertexViewerMeasurementDistance {
    /**
     * The distance from an anchor to its label.
     */
    anchorLabelOffset: number;
    /**
     * The camera used to position the anchors. If `viewer` is defined, then the projection view matrix of the viewer will be used.
     */
    camera?: FrameCameraBase;
    /**
     * Computes the bounding boxes of the anchors and label. **Note:** invoking this function uses `getBoundingClientRect` internally and will cause a relayout of the DOM.
     */
    computeElementMetrics: () => Promise<
      ViewerMeasurementDistanceElementMetrics | undefined
    >;
    /**
     * The distance between `start` and `end` in real world units. Value will be undefined if the start and end positions are undefined, or if the measurement is invalid.
     */
    distance?: number;
    /**
     * The position of the ending anchor. Can either be an instance of a `Vector3` or a JSON string representation in the format of `[x, y, z]` or `{"x": 0, "y": 0, "z": 0}`.
     */
    end?: Vector3.Vector3;
    /**
     * The position of the ending anchor, as a JSON string. Can either be an instance of a `Vector3` or a JSON string representation in the format of `[x, y, z]` or `{"x": 0, "y": 0, "z": 0}`.
     */
    endJson?: string;
    /**
     * The number of fraction digits to display.
     */
    fractionalDigits: number;
    hitProvider?: PointToPointHitProvider;
    indicatorPt?: Vector3.Vector3;
    /**
     * A property that reflects which anchor is currently being interacted with.
     */
    interactingAnchor: Anchor | 'none';
    /**
     * Indicates if the measurement is invalid. A measurement is invalid if either the start or end position are not on the surface of the model.
     */
    invalid: boolean;
    /**
     * An optional formatter that can be used to format the display of a distance. The formatting function is passed a calculated real-world distance and is expected to return a string.
     */
    labelFormatter?: Formatter<number | undefined>;
    /**
     * The length of the caps at each end of the distance measurement.
     */
    lineCapLength: number;
    /**
     * The measurement model that will be updated when this measurement changes. You can pass this to a <vertex-viewer-measurement-details> component to display measurement outcomes.
     */
    measurementModel: MeasurementModel;
    /**
     * A mode that specifies how the measurement component should behave. When unset, the component will not respond to interactions with the handles. When `edit`, the measurement anchors are interactive and the user is able to reposition them. When `replace`, anytime the user clicks on the canvas, a new measurement will be performed.
     */
    mode: ViewerMeasurementDistanceMode;
    /**
     * Enables the display of axis reference lines between the start and end point.
     */
    showAxisReferenceLines: boolean;
    /**
     * The distance, in pixels, between the mouse and nearest snappable edge. A value of 0 disables snapping.
     */
    snapDistance: number;
    /**
     * The position of the starting anchor. Can either be an instance of a `Vector3` or a JSON string representation in the format of `[x, y, z]` or `{"x": 0, "y": 0, "z": 0}`.
     */
    start?: Vector3.Vector3;
    /**
     * The position of the starting anchor, as a JSON string. Can either be an instance of a `Vector3` or a JSON string representation in the format of `[x, y, z]` or `{"x": 0, "y": 0, "z": 0}`.
     */
    startJson?: string;
    /**
     * The unit of measurement.
     */
    units: DistanceUnitType;
    /**
     * The viewer to connect to this measurement. The measurement will redraw any time the viewer redraws the scene.
     */
    viewer?: HTMLVertexViewerElement;
  }
  interface VertexViewerMeasurementLine {
    /**
     * A length of the line cap. The line cap is a line at each end of a line.
     */
    capLength: number;
    /**
     * A point that specifies the ending point of the line.
     */
    end: Point.Point;
    /**
     * The type of [SVG pointer events](https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/pointer-events) that the line should respond to.
     */
    pointerEvents: string;
    /**
     * A point that specifies the starting point of the line.
     */
    start: Point.Point;
  }
  interface VertexViewerMeasurementOverlays {
    camera?: FrameCameraBase;
    /**
     * The model that contains the overlays to present.
     */
    measurementOverlays: MeasurementOverlayManager;
    /**
     * The viewer that this component is bound to.
     */
    viewer?: HTMLVertexViewerElement;
  }
  interface VertexViewerMeasurementPrecise {
    /**
     * An optional configuration to setup network configuration of measurement endpoints.
     */
    config?: Config;
    /**
     * The environment that will be used to request measurement results.
     */
    configEnv: Environment;
    measurableEntityTypes: EntityType[];
    /**
     * The controller that is responsible for performing measurements and updating the model.
     */
    measurementController?: MeasurementController;
    /**
     * The model that contains the entities and outcomes from performing precise measurements.
     */
    measurementModel: MeasurementModel;
    /**
     * The manager that is responsible for measurement overlays to present by this component.
     */
    measurementOverlays: MeasurementOverlayManager;
    /**
     * The viewer that this component is bound to. This is automatically assigned if added to the light-dom of a parent viewer element.
     */
    viewer?: HTMLVertexViewerElement;
  }
  interface VertexViewerMeasurementTool {
    /**
     * Disables measurements.  This property will automatically be set when a child of a `<vertex-viewer-measurements>` element.
     */
    disabled: boolean;
    /**
     * An ID to an HTML template that describes the HTML content to use for distance measurements. It's expected that the template contains a `<vertex-viewer-measurement-distance>`.  This property will automatically be set when a child of a `<vertex-viewer-measurements>` element.
     */
    distanceTemplateId?: string;
    /**
     * The number of fractional digits to display measurements in.
     */
    fractionalDigits: number;
    /**
     * A property that indicates if the user is performing a measurement.
     */
    isMeasuring: boolean;
    /**
     * The distance, in pixels, between the mouse and nearest snappable edge. A value of 0 disables snapping.
     */
    snapDistance: number;
    /**
     * The type of measurement.  This property will automatically be set when a child of a `<vertex-viewer-measurements>` element.
     */
    tool: ViewerMeasurementToolType;
    /**
     * The unit type to display measurements in.
     */
    units: DistanceUnitType;
    /**
     * The viewer to connect to measurements.  This property will automatically be set when a child of a `<vertex-viewer-measurements>` or `<vertex-viewer>` element.
     */
    viewer?: HTMLVertexViewerElement;
  }
  interface VertexViewerMeasurements {
    /**
     * Adds a new measurement as a child to this component. A new measurement component will be created from the template specified by `distance-template-id` or if undefined a default element will be created.
     * @param measurement The measurement to add.
     * @returns The measurement element that was created.
     * @see {@link ViewerMeasurements.distanceTemplateId}
     */
    addMeasurement: (
      measurement: Measurement
    ) => Promise<HTMLVertexViewerMeasurementDistanceElement>;
    /**
     * If `true`, disables adding or editing of measurements through user interaction.
     */
    disabled: boolean;
    /**
     * An HTML template that describes the HTML to use for new distance measurements. It's expected that the template contains a `<vertex-viewer-measurement-distance>`.
     */
    distanceTemplateId?: string;
    /**
     * The number of fractional digits to display measurements in.
     */
    fractionalDigits: number;
    /**
     * Returns the measurement element associated to the given ID.
     * @param id The ID of the measurement element to return.
     * @returns A measurement element, or `undefined`.
     * @see {@link ViewerMeasurements.getMeasurementElements}
     */
    getMeasurementElement: (
      id: string
    ) => Promise<HTMLVertexViewerMeasurementDistanceElement | undefined>;
    /**
     * Returns a list of measurement elements that are children of this component.
     * @returns A list of all measurements.
     * @see {@link ViewerMeasurements.getMeasurementElement}
     */
    getMeasurementElements: () => Promise<
      HTMLVertexViewerMeasurementDistanceElement[]
    >;
    /**
     * The measurement model that will be updated with the selected measurement. You can pass this to a <vertex-viewer-measurement-details> component to display measurement outcomes.
     */
    measurementModel: MeasurementModel;
    /**
     * Removes a measurement with the given ID, and returns the HTML element associated to the measurement. Returns `undefined` if no measurement is found.
     * @param id The ID of the measurement to remove.
     * @returns The measurement element, or undefined.
     */
    removeMeasurement: (
      id: string
    ) => Promise<HTMLVertexViewerMeasurementDistanceElement | undefined>;
    /**
     * The ID of the measurement that is selected.
     */
    selectedMeasurementId?: string;
    /**
     * Enables the display of axis reference lines between the start and end point of selected measurements.
     */
    showAxisReferenceLines: boolean;
    /**
     * The distance, in pixels, between the mouse and nearest snappable edge. A value of 0 disables snapping.
     */
    snapDistance: number;
    /**
     * The type of measurement to perform.
     */
    tool: ViewerMeasurementToolType;
    /**
     * The unit type to display measurements in.
     */
    units: DistanceUnitType;
    /**
     * The viewer to connect to measurements. If nested within a <vertex-viewer>, this property will be populated automatically.
     */
    viewer?: HTMLVertexViewerElement;
  }
  interface VertexViewerPinGroup {
    /**
     * The dimensions of the canvas for the pins
     */
    elementBounds?: DOMRect;
    /**
     * The local matrix of this element.
     */
    matrix: Matrix4.Matrix4;
    /**
     * The pin to draw for the group
     */
    pin?: Pin;
    /**
     * The controller that drives behavior for pin operations
     */
    pinController?: PinController;
    /**
     * The model that contains the entities and outcomes from performing pin operations
     */
    pinModel: PinModel;
    /**
     * Projection view matrix used for computing the position of the pin line
     */
    projectionViewMatrix: Matrix4.Matrix4;
    /**
     * Whether or not the pin is "selected"
     */
    selected: boolean;
  }
  interface VertexViewerPinLabel {
    /**
     * The dimensions of the canvas for the pins
     */
    elementBounds?: DOMRect;
    /**
     * The pin to draw for the group
     */
    pin?: TextPin;
    /**
     * The controller that drives behavior for pin operations
     */
    pinController?: PinController;
    /**
     * Gives focus to the the component's internal text input.
     */
    setFocus: () => Promise<void>;
    /**
     * The current text value of the component. Value is updated on user interaction.
     */
    value: string;
  }
  interface VertexViewerPinLabelLine {
    labelPoint: Point.Point | undefined;
    pinPoint: Point.Point | undefined;
  }
  interface VertexViewerPinTool {
    /**
     * The mode of the pin tool
     */
    mode: ViewerPinToolMode;
    /**
     * The controller that is responsible for drawing pins and updating the model
     */
    pinController?: PinController;
    /**
     * The model that contains the entities and outcomes from performing pin annotations
     */
    pinModel: PinModel;
    pins: Pin[];
    /**
     * The type of pin.  This property will automatically be set.
     */
    tool: ViewerPinToolType;
    /**
     * The viewer that this component is bound to. This is automatically assigned if added to the light-dom of a parent viewer element.
     */
    viewer?: HTMLVertexViewerElement;
  }
  interface VertexViewerToolbar {
    direction: ViewerToolbarDirection;
    /**
     * Specifies where the toolbar is positioned.
     */
    placement: ViewerToolbarPlacement;
  }
  interface VertexViewerToolbarGroup {
    direction: ViewerToolbarGroupDirection;
  }
  interface VertexViewerTransformWidget {
    /**
     * The controller that is responsible for performing transforms.
     */
    controller?: TransformController;
    /**
     * @ignore Visible for testing.
     */
    hovered?: Drawable;
    /**
     * The starting position of this transform widget. This position will be updated as transforms occur. Setting this value to `undefined` will remove the widget.
     */
    position?: Vector3.Vector3;
    /**
     * The viewer to connect to transforms. If nested within a <vertex-viewer>, this property will be populated automatically.
     */
    viewer?: HTMLVertexViewerElement;
  }
  interface VertexViewerViewCube {
    /**
     * The duration of the animation, in milliseconds, when a user performs a standard view interaction. Set to 0 to disable animations.
     */
    animationDuration: number;
    camera?: FramePerspectiveCamera;
    /**
     * Disables interactions for standard views.
     */
    standardViewsOff: boolean;
    /**
     * Disables the display of the triad.
     */
    triadOff: boolean;
    /**
     * The viewer element that is connected to the view cube.
     */
    viewer?: HTMLVertexViewerElement;
    worldOrientation: Orientation;
    /**
     * The label for the side of the cube on the negative x-axis.
     */
    xNegativeLabel: string;
    /**
     * The label for the side of the cube on the positive x-axis.
     */
    xPositiveLabel: string;
    /**
     * The label for the side of the cube on the negative y-axis.
     */
    yNegativeLabel: string;
    /**
     * The label for the side of the cube on the positive y-axis.
     */
    yPositiveLabel: string;
    /**
     * The label for the side of the cube on the negative z-axis.
     */
    zNegativeLabel: string;
    /**
     * The label for the side of the cube on the positive z-axis.
     */
    zPositiveLabel: string;
  }
}
declare global {
  interface HTMLVertexSceneTreeElement
    extends Components.VertexSceneTree,
      HTMLStencilElement {}
  var HTMLVertexSceneTreeElement: {
    prototype: HTMLVertexSceneTreeElement;
    new (): HTMLVertexSceneTreeElement;
  };
  interface HTMLVertexSceneTreeSearchElement
    extends Components.VertexSceneTreeSearch,
      HTMLStencilElement {}
  var HTMLVertexSceneTreeSearchElement: {
    prototype: HTMLVertexSceneTreeSearchElement;
    new (): HTMLVertexSceneTreeSearchElement;
  };
  interface HTMLVertexSceneTreeTableCellElement
    extends Components.VertexSceneTreeTableCell,
      HTMLStencilElement {}
  var HTMLVertexSceneTreeTableCellElement: {
    prototype: HTMLVertexSceneTreeTableCellElement;
    new (): HTMLVertexSceneTreeTableCellElement;
  };
  interface HTMLVertexSceneTreeTableColumnElement
    extends Components.VertexSceneTreeTableColumn,
      HTMLStencilElement {}
  var HTMLVertexSceneTreeTableColumnElement: {
    prototype: HTMLVertexSceneTreeTableColumnElement;
    new (): HTMLVertexSceneTreeTableColumnElement;
  };
  interface HTMLVertexSceneTreeTableHeaderElement
    extends Components.VertexSceneTreeTableHeader,
      HTMLStencilElement {}
  var HTMLVertexSceneTreeTableHeaderElement: {
    prototype: HTMLVertexSceneTreeTableHeaderElement;
    new (): HTMLVertexSceneTreeTableHeaderElement;
  };
  interface HTMLVertexSceneTreeTableLayoutElement
    extends Components.VertexSceneTreeTableLayout,
      HTMLStencilElement {}
  var HTMLVertexSceneTreeTableLayoutElement: {
    prototype: HTMLVertexSceneTreeTableLayoutElement;
    new (): HTMLVertexSceneTreeTableLayoutElement;
  };
  interface HTMLVertexSceneTreeTableResizeDividerElement
    extends Components.VertexSceneTreeTableResizeDivider,
      HTMLStencilElement {}
  var HTMLVertexSceneTreeTableResizeDividerElement: {
    prototype: HTMLVertexSceneTreeTableResizeDividerElement;
    new (): HTMLVertexSceneTreeTableResizeDividerElement;
  };
  interface HTMLVertexSceneTreeToolbarElement
    extends Components.VertexSceneTreeToolbar,
      HTMLStencilElement {}
  var HTMLVertexSceneTreeToolbarElement: {
    prototype: HTMLVertexSceneTreeToolbarElement;
    new (): HTMLVertexSceneTreeToolbarElement;
  };
  interface HTMLVertexSceneTreeToolbarGroupElement
    extends Components.VertexSceneTreeToolbarGroup,
      HTMLStencilElement {}
  var HTMLVertexSceneTreeToolbarGroupElement: {
    prototype: HTMLVertexSceneTreeToolbarGroupElement;
    new (): HTMLVertexSceneTreeToolbarGroupElement;
  };
  interface HTMLVertexViewerElement
    extends Components.VertexViewer,
      HTMLStencilElement {}
  var HTMLVertexViewerElement: {
    prototype: HTMLVertexViewerElement;
    new (): HTMLVertexViewerElement;
  };
  interface HTMLVertexViewerButtonElement
    extends Components.VertexViewerButton,
      HTMLStencilElement {}
  var HTMLVertexViewerButtonElement: {
    prototype: HTMLVertexViewerButtonElement;
    new (): HTMLVertexViewerButtonElement;
  };
  interface HTMLVertexViewerDefaultToolbarElement
    extends Components.VertexViewerDefaultToolbar,
      HTMLStencilElement {}
  var HTMLVertexViewerDefaultToolbarElement: {
    prototype: HTMLVertexViewerDefaultToolbarElement;
    new (): HTMLVertexViewerDefaultToolbarElement;
  };
  interface HTMLVertexViewerDomElementElement
    extends Components.VertexViewerDomElement,
      HTMLStencilElement {}
  var HTMLVertexViewerDomElementElement: {
    prototype: HTMLVertexViewerDomElementElement;
    new (): HTMLVertexViewerDomElementElement;
  };
  interface HTMLVertexViewerDomGroupElement
    extends Components.VertexViewerDomGroup,
      HTMLStencilElement {}
  var HTMLVertexViewerDomGroupElement: {
    prototype: HTMLVertexViewerDomGroupElement;
    new (): HTMLVertexViewerDomGroupElement;
  };
  interface HTMLVertexViewerDomRendererElement
    extends Components.VertexViewerDomRenderer,
      HTMLStencilElement {}
  var HTMLVertexViewerDomRendererElement: {
    prototype: HTMLVertexViewerDomRendererElement;
    new (): HTMLVertexViewerDomRendererElement;
  };
  interface HTMLVertexViewerIconElement
    extends Components.VertexViewerIcon,
      HTMLStencilElement {}
  var HTMLVertexViewerIconElement: {
    prototype: HTMLVertexViewerIconElement;
    new (): HTMLVertexViewerIconElement;
  };
  interface HTMLVertexViewerLayerElement
    extends Components.VertexViewerLayer,
      HTMLStencilElement {}
  var HTMLVertexViewerLayerElement: {
    prototype: HTMLVertexViewerLayerElement;
    new (): HTMLVertexViewerLayerElement;
  };
  interface HTMLVertexViewerMarkupElement
    extends Components.VertexViewerMarkup,
      HTMLStencilElement {}
  var HTMLVertexViewerMarkupElement: {
    prototype: HTMLVertexViewerMarkupElement;
    new (): HTMLVertexViewerMarkupElement;
  };
  interface HTMLVertexViewerMarkupArrowElement
    extends Components.VertexViewerMarkupArrow,
      HTMLStencilElement {}
  var HTMLVertexViewerMarkupArrowElement: {
    prototype: HTMLVertexViewerMarkupArrowElement;
    new (): HTMLVertexViewerMarkupArrowElement;
  };
  interface HTMLVertexViewerMarkupCircleElement
    extends Components.VertexViewerMarkupCircle,
      HTMLStencilElement {}
  var HTMLVertexViewerMarkupCircleElement: {
    prototype: HTMLVertexViewerMarkupCircleElement;
    new (): HTMLVertexViewerMarkupCircleElement;
  };
  interface HTMLVertexViewerMarkupFreeformElement
    extends Components.VertexViewerMarkupFreeform,
      HTMLStencilElement {}
  var HTMLVertexViewerMarkupFreeformElement: {
    prototype: HTMLVertexViewerMarkupFreeformElement;
    new (): HTMLVertexViewerMarkupFreeformElement;
  };
  interface HTMLVertexViewerMarkupToolElement
    extends Components.VertexViewerMarkupTool,
      HTMLStencilElement {}
  var HTMLVertexViewerMarkupToolElement: {
    prototype: HTMLVertexViewerMarkupToolElement;
    new (): HTMLVertexViewerMarkupToolElement;
  };
  interface HTMLVertexViewerMeasurementDetailsElement
    extends Components.VertexViewerMeasurementDetails,
      HTMLStencilElement {}
  var HTMLVertexViewerMeasurementDetailsElement: {
    prototype: HTMLVertexViewerMeasurementDetailsElement;
    new (): HTMLVertexViewerMeasurementDetailsElement;
  };
  interface HTMLVertexViewerMeasurementDistanceElement
    extends Components.VertexViewerMeasurementDistance,
      HTMLStencilElement {}
  var HTMLVertexViewerMeasurementDistanceElement: {
    prototype: HTMLVertexViewerMeasurementDistanceElement;
    new (): HTMLVertexViewerMeasurementDistanceElement;
  };
  interface HTMLVertexViewerMeasurementLineElement
    extends Components.VertexViewerMeasurementLine,
      HTMLStencilElement {}
  var HTMLVertexViewerMeasurementLineElement: {
    prototype: HTMLVertexViewerMeasurementLineElement;
    new (): HTMLVertexViewerMeasurementLineElement;
  };
  interface HTMLVertexViewerMeasurementOverlaysElement
    extends Components.VertexViewerMeasurementOverlays,
      HTMLStencilElement {}
  var HTMLVertexViewerMeasurementOverlaysElement: {
    prototype: HTMLVertexViewerMeasurementOverlaysElement;
    new (): HTMLVertexViewerMeasurementOverlaysElement;
  };
  interface HTMLVertexViewerMeasurementPreciseElement
    extends Components.VertexViewerMeasurementPrecise,
      HTMLStencilElement {}
  var HTMLVertexViewerMeasurementPreciseElement: {
    prototype: HTMLVertexViewerMeasurementPreciseElement;
    new (): HTMLVertexViewerMeasurementPreciseElement;
  };
  interface HTMLVertexViewerMeasurementToolElement
    extends Components.VertexViewerMeasurementTool,
      HTMLStencilElement {}
  var HTMLVertexViewerMeasurementToolElement: {
    prototype: HTMLVertexViewerMeasurementToolElement;
    new (): HTMLVertexViewerMeasurementToolElement;
  };
  interface HTMLVertexViewerMeasurementsElement
    extends Components.VertexViewerMeasurements,
      HTMLStencilElement {}
  var HTMLVertexViewerMeasurementsElement: {
    prototype: HTMLVertexViewerMeasurementsElement;
    new (): HTMLVertexViewerMeasurementsElement;
  };
  interface HTMLVertexViewerPinGroupElement
    extends Components.VertexViewerPinGroup,
      HTMLStencilElement {}
  var HTMLVertexViewerPinGroupElement: {
    prototype: HTMLVertexViewerPinGroupElement;
    new (): HTMLVertexViewerPinGroupElement;
  };
  interface HTMLVertexViewerPinLabelElement
    extends Components.VertexViewerPinLabel,
      HTMLStencilElement {}
  var HTMLVertexViewerPinLabelElement: {
    prototype: HTMLVertexViewerPinLabelElement;
    new (): HTMLVertexViewerPinLabelElement;
  };
  interface HTMLVertexViewerPinLabelLineElement
    extends Components.VertexViewerPinLabelLine,
      HTMLStencilElement {}
  var HTMLVertexViewerPinLabelLineElement: {
    prototype: HTMLVertexViewerPinLabelLineElement;
    new (): HTMLVertexViewerPinLabelLineElement;
  };
  interface HTMLVertexViewerPinToolElement
    extends Components.VertexViewerPinTool,
      HTMLStencilElement {}
  var HTMLVertexViewerPinToolElement: {
    prototype: HTMLVertexViewerPinToolElement;
    new (): HTMLVertexViewerPinToolElement;
  };
  interface HTMLVertexViewerToolbarElement
    extends Components.VertexViewerToolbar,
      HTMLStencilElement {}
  var HTMLVertexViewerToolbarElement: {
    prototype: HTMLVertexViewerToolbarElement;
    new (): HTMLVertexViewerToolbarElement;
  };
  interface HTMLVertexViewerToolbarGroupElement
    extends Components.VertexViewerToolbarGroup,
      HTMLStencilElement {}
  var HTMLVertexViewerToolbarGroupElement: {
    prototype: HTMLVertexViewerToolbarGroupElement;
    new (): HTMLVertexViewerToolbarGroupElement;
  };
  interface HTMLVertexViewerTransformWidgetElement
    extends Components.VertexViewerTransformWidget,
      HTMLStencilElement {}
  var HTMLVertexViewerTransformWidgetElement: {
    prototype: HTMLVertexViewerTransformWidgetElement;
    new (): HTMLVertexViewerTransformWidgetElement;
  };
  interface HTMLVertexViewerViewCubeElement
    extends Components.VertexViewerViewCube,
      HTMLStencilElement {}
  var HTMLVertexViewerViewCubeElement: {
    prototype: HTMLVertexViewerViewCubeElement;
    new (): HTMLVertexViewerViewCubeElement;
  };
  interface HTMLElementTagNameMap {
    'vertex-scene-tree': HTMLVertexSceneTreeElement;
    'vertex-scene-tree-search': HTMLVertexSceneTreeSearchElement;
    'vertex-scene-tree-table-cell': HTMLVertexSceneTreeTableCellElement;
    'vertex-scene-tree-table-column': HTMLVertexSceneTreeTableColumnElement;
    'vertex-scene-tree-table-header': HTMLVertexSceneTreeTableHeaderElement;
    'vertex-scene-tree-table-layout': HTMLVertexSceneTreeTableLayoutElement;
    'vertex-scene-tree-table-resize-divider': HTMLVertexSceneTreeTableResizeDividerElement;
    'vertex-scene-tree-toolbar': HTMLVertexSceneTreeToolbarElement;
    'vertex-scene-tree-toolbar-group': HTMLVertexSceneTreeToolbarGroupElement;
    'vertex-viewer': HTMLVertexViewerElement;
    'vertex-viewer-button': HTMLVertexViewerButtonElement;
    'vertex-viewer-default-toolbar': HTMLVertexViewerDefaultToolbarElement;
    'vertex-viewer-dom-element': HTMLVertexViewerDomElementElement;
    'vertex-viewer-dom-group': HTMLVertexViewerDomGroupElement;
    'vertex-viewer-dom-renderer': HTMLVertexViewerDomRendererElement;
    'vertex-viewer-icon': HTMLVertexViewerIconElement;
    'vertex-viewer-layer': HTMLVertexViewerLayerElement;
    'vertex-viewer-markup': HTMLVertexViewerMarkupElement;
    'vertex-viewer-markup-arrow': HTMLVertexViewerMarkupArrowElement;
    'vertex-viewer-markup-circle': HTMLVertexViewerMarkupCircleElement;
    'vertex-viewer-markup-freeform': HTMLVertexViewerMarkupFreeformElement;
    'vertex-viewer-markup-tool': HTMLVertexViewerMarkupToolElement;
    'vertex-viewer-measurement-details': HTMLVertexViewerMeasurementDetailsElement;
    'vertex-viewer-measurement-distance': HTMLVertexViewerMeasurementDistanceElement;
    'vertex-viewer-measurement-line': HTMLVertexViewerMeasurementLineElement;
    'vertex-viewer-measurement-overlays': HTMLVertexViewerMeasurementOverlaysElement;
    'vertex-viewer-measurement-precise': HTMLVertexViewerMeasurementPreciseElement;
    'vertex-viewer-measurement-tool': HTMLVertexViewerMeasurementToolElement;
    'vertex-viewer-measurements': HTMLVertexViewerMeasurementsElement;
    'vertex-viewer-pin-group': HTMLVertexViewerPinGroupElement;
    'vertex-viewer-pin-label': HTMLVertexViewerPinLabelElement;
    'vertex-viewer-pin-label-line': HTMLVertexViewerPinLabelLineElement;
    'vertex-viewer-pin-tool': HTMLVertexViewerPinToolElement;
    'vertex-viewer-toolbar': HTMLVertexViewerToolbarElement;
    'vertex-viewer-toolbar-group': HTMLVertexViewerToolbarGroupElement;
    'vertex-viewer-transform-widget': HTMLVertexViewerTransformWidgetElement;
    'vertex-viewer-view-cube': HTMLVertexViewerViewCubeElement;
  }
}
declare namespace LocalJSX {
  interface VertexSceneTree {
    /**
     * An object to configure the scene tree.
     */
    config?: Config;
    /**
     * Sets the default environment for the viewer. This setting is used for auto-configuring network hosts.  Use the `config` property for manually setting hosts.
     */
    configEnv?: Environment;
    controller?: SceneTreeController;
    /**
     * A list of part metadata keys that will be made available to each row. This metadata can be used for data binding inside the scene tree's template.
     */
    metadataKeys?: MetadataKey[];
    /**
     * Indicates whether the metadata search should use an exact match.
     */
    metadataSearchExactMatch?: boolean;
    /**
     * A list of the metadata keys that a scene tree search should be performed on.
     */
    metadataSearchKeys?: MetadataKey[];
    onConnectionError?: (event: CustomEvent<SceneTreeErrorDetails>) => void;
    /**
     * The number of offscreen rows above and below the viewport to render. Having a higher number reduces the chance of the browser not displaying a row while scrolling.
     */
    overScanCount?: number;
    /**
     * A callback that is invoked immediately before a row is about to rendered. This callback can return additional data that can be bound to in a template.
     * @example ```html <script>   const table = document.querySelector('vertex-scene-tree-table');   table.rowData = (row) => {     return { func: () => console.log('row', row.node.name) };   } </script>  <vertex-scene-tree>  <vertex-scene-tree-table>    <vertex-scene-tree-table-column>      <template>        <button event:click="{{row.data.func}}">Hi</button>      </template>    </vertex-scene-tree-table-column>  </vertex-scene-tree-table> </vertex-scene-tree> ```
     */
    rowData?: RowDataProvider;
    /**
     * An instance of a `<vertex-viewer>` element. Either this property or `viewerSelector` must be set.
     */
    viewer?: HTMLVertexViewerElement | null;
    /**
     * A CSS selector that points to a `<vertex-viewer>` element. Either this property or `viewer` must be set.
     */
    viewerSelector?: string;
  }
  interface VertexSceneTreeSearch {
    /**
     * Specifies the delay, in milliseconds, to emit `search` events after user input.
     */
    debounce?: number;
    /**
     * If `true`, disables user interaction of the component.
     */
    disabled?: boolean;
    /**
     * An event that is emitted when a user has inputted or cleared the search term. The event may be delayed according to the current `debounce` value.
     */
    onSearch?: (event: CustomEvent<string>) => void;
    /**
     * Placeholder text if `value` is empty.
     */
    placeholder?: string;
    /**
     * The current text value of the component. Value is updated on user interaction.
     */
    value?: string;
  }
  interface VertexSceneTreeTableCell {
    /**
     * Indicates whether to display a button for toggling the expanded state of the node associated with this cell.
     */
    expandToggle?: boolean;
    hoveredNodeId?: string;
    /**
     * A flag that disables the default interactions of this component. If disabled, you can use the event handlers to be notified when certain operations are performed by the user.
     */
    interactionsDisabled?: boolean;
    isScrolling?: boolean;
    /**
     * The node data that is associated to the row that this cell belongs to. Contains information related to if the node is expanded, visible, etc.
     */
    node?: Node.AsObject;
    /**
     * An event that is emitted when a user requests to expand the node. This is emitted even if interactions are disabled.
     */
    onExpandToggled?: (
      event: CustomEvent<SceneTreeTableCellEventDetails>
    ) => void;
    onHovered?: (
      event: CustomEvent<SceneTreeTableCellEventDetails | undefined>
    ) => void;
    /**
     * An event that is emitted when a user requests to change the node's selection state. This event is emitted even if interactions are disabled.
     */
    onSelectionToggled?: (
      event: CustomEvent<SceneTreeTableCellEventDetails>
    ) => void;
    /**
     * An event that is emitted when a user requests to change the node's visibility. This event is emitted even if interactions are disabled.
     */
    onVisibilityToggled?: (
      event: CustomEvent<SceneTreeTableCellEventDetails>
    ) => void;
    /**
     * The value to display in this cell if the `value` specified is undefined. Defaults to "--".
     */
    placeholder?: string;
    /**
     * A flag that disables selection of the node's parent if the user selects the row multiple times. When enabled, selection of the same row multiple times will recursively select the next unselected parent until the root node is selected.
     */
    recurseParentSelectionDisabled?: boolean;
    /**
     * A reference to the scene tree to perform operations for interactions. Such as expansion, visibility and selection.
     */
    tree?: HTMLVertexSceneTreeElement;
    /**
     * The value to display in this cell.
     */
    value?: string;
    /**
     * Indicates whether to display a button for toggling the visibility state of the node associated with this cell.
     */
    visibilityToggle?: boolean;
  }
  interface VertexSceneTreeTableColumn {
    /**
     * The initial width of this column.
     */
    initialWidth?: number;
    /**
     * The maximum width of this column.
     */
    maxWidth?: number;
    /**
     * The minimum width of this column.
     */
    minWidth?: number;
  }
  interface VertexSceneTreeTableHeader {}
  interface VertexSceneTreeTableLayout {
    controller?: SceneTreeController;
    layoutHeight?: number;
    layoutOffset?: number;
    layoutWidth?: number;
    onLayoutRendered?: (event: CustomEvent<void>) => void;
    /**
     * The number of offscreen rows above and below the viewport to render. Having a higher number reduces the chance of the browser not displaying a row while scrolling.  This prop will be automatically populated based on the `overScanCount` prop specified in the parent `<vertex-scene-tree />` element.
     */
    overScanCount?: number;
    /**
     * A callback that is invoked immediately before a row is about to rendered. This callback can return additional data that can be bound to in a template.  This prop will be automatically populated based on the `rowData` prop specified in the parent `<vertex-scene-tree />` element.
     * @example ```html <script>   const table = document.querySelector('vertex-scene-tree-table');   table.rowData = (row) => {     return { func: () => console.log('row', row.node.name) };   } </script>  <vertex-scene-tree>  <vertex-scene-tree-table>    <vertex-scene-tree-table-column>      <template>        <button event:click="{{row.data.func}}">Hi</button>      </template>    </vertex-scene-tree-table-column>  </vertex-scene-tree-table> </vertex-scene-tree> ```
     */
    rowData?: RowDataProvider;
    rowHeight?: number;
    rows?: Row[];
    scrollOffset?: number;
    totalRows?: number;
    /**
     * A reference to the scene tree to perform operations for interactions. Such as expansion, visibility and selection.
     */
    tree?: HTMLVertexSceneTreeElement;
    viewportEndIndex?: number;
    viewportStartIndex?: number;
  }
  interface VertexSceneTreeTableResizeDivider {}
  interface VertexSceneTreeToolbar {}
  interface VertexSceneTreeToolbarGroup {}
  interface VertexViewer {
    /**
     * Enables or disables the default mouse and touch interactions provided by the viewer. Enabled by default.
     */
    cameraControls?: boolean;
    /**
     * The type of camera model to represent the scene with. Can be either `perspective` or `orthographic`, and defaults to `perspective`.
     */
    cameraType?: FrameCameraType;
    /**
     * The Client ID associated with your Vertex Application.
     */
    clientId?: string;
    /**
     * An object or JSON encoded string that defines configuration settings for the viewer.
     */
    config?: Config | string;
    /**
     * Sets the default environment for the viewer. This setting is used for auto-configuring network hosts.  Use the `config` property for manually setting hosts.
     * @see Viewer.config
     */
    configEnv?: Environment;
    /**
     * Specifies when a depth buffer is requested from rendering. Possible values are:  * `undefined`: A depth buffer is never requested. * `final`: A depth buffer is only requested on the final frame. * `all`: A depth buffer is requested for every frame.  Depth buffers can increase the amount of data that's sent to a client and can impact rendering performance. Values of `undefined` or `final` should be used when needing the highest rendering performance.
     */
    depthBuffers?: FrameType;
    /**
     * Property used for internals or testing.
     * @private
     */
    deviceId?: string;
    /**
     * Specifies the opacity, between 0 and 100, for an experimental ghosting feature. When the value is non-zero, any scene items that are hidden will be appear translucent.  **Note:** This feature is experimental, and may cause slower frame rates.
     */
    experimentalGhostingOpacity?: number;
    /**
     * Specifies how selected features should be highlighted.
     */
    featureHighlighting?: FeatureHighlightOptions;
    /**
     * Specifies if and how to render feature lines.
     */
    featureLines?: FeatureLineOptions;
    /**
     * Specifies when a feature map is returned from rendering. Feature maps include information about the surfaces, edges and cross sections that are in a frame.  Possible values are:  * `undefined`: A feature map is never requested. * `final`: A feature map is only requested on the final frame. * `all`: A feature map is requested for every frame.  Feature maps can increase the amount of data that's sent to a client and can impact rendering performance. Values of `undefined` or `final` should be used when needing the highest rendering performance.
     */
    featureMaps?: FrameType;
    /**
     * The last frame that was received, which can be used to inspect the scene and camera information.
     * @readonly
     */
    frame?: Frame | undefined;
    /**
     * Enables or disables the default keyboard shortcut interactions provided by the viewer. Enabled by default, requires `cameraControls` being enabled.
     */
    keyboardControls?: boolean;
    /**
     * Specifies whether to use the default lights for the scene. When false, default lights are used. When true, no default lights are used, and the lights must be specified separately.
     */
    noDefaultLights?: boolean;
    /**
     * Emits an event when the camera type changes.
     */
    onCameraTypeChanged?: (event: CustomEvent<FrameCameraType>) => void;
    /**
     * Emits an event when the connection status changes for the viewer
     */
    onConnectionChange?: (event: CustomEvent<ConnectionStatus>) => void;
    /**
     * Used for internals or testing.
     * @private
     */
    onDeviceIdChange?: (event: CustomEvent<string>) => void;
    onDimensionschange?: (event: CustomEvent<Dimensions.Dimensions>) => void;
    /**
     * Emits an event whenever the user double taps or clicks a location in the viewer. The event includes the location of the first tap or click.
     */
    onDoubletap?: (event: CustomEvent<TapEventDetails>) => void;
    /**
     * Emits an event when a frame has been drawn to the viewer's canvas. The event will include details about the drawn frame, such as the `Scene` information related to the scene.
     */
    onFrameDrawn?: (event: CustomEvent<Frame>) => void;
    /**
     * Emits an event when a frame has been received by the viewer. The event will include details about the drawn frame, such as the `Scene` information related to the scene.
     */
    onFrameReceived?: (event: CustomEvent<Frame>) => void;
    /**
     * Emits an event when the user hs finished an interaction.
     */
    onInteractionFinished?: (event: CustomEvent<void>) => void;
    /**
     * Emits an event when the user has started an interaction.
     */
    onInteractionStarted?: (event: CustomEvent<void>) => void;
    /**
     * Emits an event whenever the user taps or clicks a location in the viewer and the configured amount of time passes without receiving a mouseup or touchend. The event includes the location of the tap or click.
     */
    onLongpress?: (event: CustomEvent<TapEventDetails>) => void;
    /**
     * Emits an event when a frame is received with a different scene attribute.
     */
    onSceneChanged?: (event: CustomEvent<void>) => void;
    /**
     * Emits an event when the scene is ready to be interacted with.
     */
    onSceneReady?: (event: CustomEvent<void>) => void;
    /**
     * Emits an event whenever the user taps or clicks a location in the viewer. The event includes the location of the tap or click.
     */
    onTap?: (event: CustomEvent<TapEventDetails>) => void;
    /**
     * Emits an event when a provided oauth2 token is about to expire, or is about to expire, causing issues with establishing a websocket connection, or performing API calls.
     */
    onTokenExpired?: (event: CustomEvent<void>) => void;
    /**
     * An optional value that will debounce frame updates when resizing this viewer element.
     */
    resizeDebounce?: number;
    resolvedConfig?: Config;
    /**
     * Enables or disables the default rotation interaction being changed to rotate around the pointer down location.
     */
    rotateAroundTapPoint?: boolean;
    /**
     * The default hex color or material to use when selecting items.
     */
    selectionMaterial?: string | ColorMaterial;
    /**
     * A URN of the scene resource to load when the component is mounted in the DOM tree. The specified resource is a URN in the following format:   * `urn:vertexvis:scene:<sceneid>`
     */
    src?: string;
    stencilBuffer?: StencilBufferManager;
    stream?: ViewerStream;
    /**
     * A token that can be used to make API calls to other Vertex services.
     */
    token?: string;
    /**
     * Represents the current viewport of the viewer. The viewport represents the dimensions of the canvas where a frame is rendered. It contains methods for translating between viewport coordinates, frame coordinates and world coordinates.
     */
    viewport?: Viewport;
  }
  interface VertexViewerButton {}
  interface VertexViewerDefaultToolbar {
    /**
     * The duration of animations, in milliseconds. Defaults to `1000`.
     */
    animationMs?: number;
    /**
     * Indicates whether animations will be used when performing camera operations. Defaults to `true`.
     */
    animationsDisabled?: boolean;
    /**
     * Specifies the direction that UI elements are placed.
     */
    direction?: ViewerToolbarGroupDirection;
    /**
     * Specifies where the toolbar is positioned.
     */
    placement?: ViewerToolbarPlacement;
    /**
     * An instance of the viewer that operations will be performed on. If contained within a `<vertex-viewer>` element, this property will automatically be wired.
     */
    viewer?: HTMLVertexViewerElement;
  }
  interface VertexViewerDomElement {
    /**
     * Disables the billboarding behavior of the element. When billboarding is enabled, the element will always be oriented towards the screen.
     */
    billboardOff?: boolean;
    /**
     * Disables interaction events from children.
     */
    interactionsOff?: boolean;
    /**
     * The local matrix of this element.
     */
    matrix?: Matrix4.Matrix4;
    /**
     * Indicates if the element is hidden by geometry. This property can be used with a CSS selector to modify the appearance of the element when its occluded.
     * @example ```html <style>   vertex-viewer-dom-element[occluded] {     opacity: 0;   } </style> ```
     */
    occluded?: boolean;
    /**
     * Disables occlusion testing for this element. Defaults to enabled. When enabled, the elements position will be tested against the current depth buffer. If the position is occluded, then the `occluded` attribute will be set.
     */
    occlusionOff?: boolean;
    /**
     * An event that is emitted when any property on the dom group changes
     */
    onPropertyChange?: (event: CustomEvent<void>) => void;
    /**
     * The local 3D position of where this element is located.
     */
    position?: Vector3.Vector3;
    /**
     * The local 3D position of where this element is located, as a JSON string. JSON representation can either be in the format of `[x, y, z]` or `{"x": 0, "y": 0, "z": 0}`.
     */
    positionJson?: string;
    /**
     * The local rotation of this element.
     */
    quaternion?: Quaternion.Quaternion;
    /**
     * The local quaternion rotation of this element, as a JSON string. JSON representation can either be `[x, y, z, w]` or `{"x": 0, "y": 0, "z": 0, "w": 1}`.
     */
    quaternionJson?: string;
    /**
     * The local rotation of this element in Euler angles.
     */
    rotation?: Euler.Euler;
    /**
     * The local rotation of this element in Euler angles, as a JSON string. JSON representation can either be `[x, y, z, order]` or `{"x": 0, "y": 0, "z": 0, "order": "xyz"}`.
     */
    rotationJson?: string;
    /**
     * The local scale of this element.
     */
    scale?: Vector3.Vector3;
    /**
     * The local scale of this element, as a JSON string. JSON string representation can either be in the format of `[x, y, z]` or `{"x": 0, "y": 0, "z": 0}`.
     */
    scaleJson?: string;
  }
  interface VertexViewerDomGroup {
    /**
     * The local matrix of this element.
     */
    matrix?: Matrix4.Matrix4;
    /**
     * An event that is emitted when any property on the dom group changes
     */
    onPropertyChange?: (event: CustomEvent<void>) => void;
    /**
     * The local 3D position of where this element is located.
     */
    position?: Vector3.Vector3;
    /**
     * The local 3D position of where this element is located, as a JSON string. JSON representation can either be in the format of `[x, y, z]` or `{"x": 0, "y": 0, "z": 0}`.
     */
    positionJson?: string;
    /**
     * The local rotation of this element.
     */
    quaternion?: Quaternion.Quaternion;
    /**
     * The local rotation of this element, as a JSON string. JSON representation can either be `[x, y, z, w]` or `{"x": 0, "y": 0, "z": 0, "w": 1}`.
     */
    quaternionJson?: string;
    /**
     * The local rotation of this element in Euler angles.
     */
    rotation?: Euler.Euler;
    /**
     * The local rotation of this element in Euler angles, as a JSON string. JSON representation can either be `[x, y, z, order]` or `{"x": 0, "y": 0, "z": 0, "order": "xyz"}`.
     */
    rotationJson?: string;
    /**
     * The local scale of this element.
     */
    scale?: Vector3.Vector3;
    /**
     * The local scale of this element, as a JSON string. JSON string representation can either be in the format of `[x, y, z]` or `{"x": 0, "y": 0, "z": 0}`.
     */
    scaleJson?: string;
  }
  interface VertexViewerDomRenderer {
    /**
     * The current camera of the frame.  This property will automatically be set when supplying a viewer to the component, or when added as a child to `<vertex-viewer>`.
     */
    camera?: FrameCameraBase;
    /**
     * The current depth buffer of the frame.  This property will automatically be set when supplying a viewer to the component, or when added as a child to `<vertex-viewer>`.
     */
    depthBuffer?: DepthBuffer;
    /**
     * Specifies the drawing mode for the renderer.  When in `3d` mode, elements are positioned using CSS 3D transforms and will scale and rotate with the camera. In `2d` mode, a simpler 2D transform is used, and elements will not scale or rotate with camera changes.
     */
    drawMode?: ViewerDomRendererDrawMode;
    /**
     * The viewer synced to this renderer. This property will automatically be assigned if the renderer is a child of `<vertex-viewer>`.
     */
    viewer?: HTMLVertexViewerElement;
  }
  interface VertexViewerIcon {
    /**
     * The name of the icon to render.
     */
    name?: ViewerIconName;
    /**
     * The size of the icon. Can be `'sm' | 'md' | 'lg' | undefined`. Predefined sizes are set to:   * `sm`: 16px  * `md`: 24px  * `lg`: 32px  A custom size can be supplied by setting this field to `undefined` and setting `font-size` through CSS. Defaults to `md`.
     */
    size?: ViewerIconSize;
  }
  interface VertexViewerLayer {
    /**
     * Indicates if the layer should stretch to fill the size of its container's nearest positioned parent.
     */
    stretchOff?: boolean;
  }
  interface VertexViewerMarkup {
    /**
     * An HTML template that describes the HTML to use for new arrow markup. It's expected that the template contains a `<vertex-viewer-markup-arrow>`.
     */
    arrowTemplateId?: string;
    /**
     * An HTML template that describes the HTML to use for new circle markup. It's expected that the template contains a `<vertex-viewer-markup-circle>`.
     */
    circleTemplateId?: string;
    /**
     * If `true`, disables adding or editing of markup through user interaction.
     */
    disabled?: boolean;
    /**
     * An HTML template that describes the HTML to use for new freeform markup. It's expected that the template contains a `<vertex-viewer-markup-freeform>`.
     */
    freeformTemplateId?: string;
    /**
     * Dispatched when a new markup is added, either through user interaction or programmatically.
     */
    onMarkupAdded?: (
      event: CustomEvent<
        | HTMLVertexViewerMarkupArrowElement
        | HTMLVertexViewerMarkupCircleElement
        | HTMLVertexViewerMarkupFreeformElement
      >
    ) => void;
    /**
     * Dispatched when a markup is removed, either through user interaction or programmatically.
     */
    onMarkupRemoved?: (
      event: CustomEvent<
        | HTMLVertexViewerMarkupArrowElement
        | HTMLVertexViewerMarkupCircleElement
        | HTMLVertexViewerMarkupFreeformElement
      >
    ) => void;
    /**
     * Indicates if new markup should be automatically selected.
     */
    selectNew?: boolean;
    /**
     * The ID of the markup that is selected.
     */
    selectedMarkupId?: string;
    /**
     * The type of markup to perform.
     */
    tool?: ViewerMarkupToolType;
    /**
     * The viewer to connect to markup. If nested within a <vertex-viewer>, this property will be populated automatically.
     */
    viewer?: HTMLVertexViewerElement;
  }
  interface VertexViewerMarkupArrow {
    /**
     * The position of the ending anchor. Can either be an instance of a `Point` or a JSON string representation in the format of `[x, y]` or `{"x": 0, "y": 0}`.  Points are expected to be relative coordinates from `[-0.5, 0.5]`, e.g. `[0, 0]` corresponds to a point in the center of the viewport.
     */
    end?: Point.Point;
    /**
     * The position of the ending anchor, as a JSON string. Can either be an instance of a `Point` or a JSON string representation in the format of `[x, y]` or `{"x": 0, "y": 0}`.  Points are expected to be relative coordinates from `[-0.5, 0.5]`, e.g. `[0, 0]` corresponds to a point in the center of the viewport.
     */
    endJson?: string;
    /**
     * A mode that specifies how the markup component should behave. When unset, the component will not respond to interactions with the handles. When `edit`, the markup anchors are interactive and the user is able to reposition them. When `create`, anytime the user clicks on the canvas, a new markup will be performed.
     */
    mode?: ViewerMarkupArrowMode;
    /**
     * An event that is dispatched anytime the user begins editing the markup.
     */
    onEditBegin?: (event: CustomEvent<void>) => void;
    /**
     * An event that is dispatched when the user has finished editing the markup.
     */
    onEditEnd?: (event: CustomEvent<void>) => void;
    /**
     * An event that is dispatched when this markup element is in view mode (`this.mode === ""`), and it completes a rerender.
     */
    onViewRendered?: (event: CustomEvent<void>) => void;
    /**
     * The position of the starting anchor. Can either be an instance of a `Point` or a JSON string representation in the format of `[x, y]` or `{"x": 0, "y": 0}`.  Points are expected to be relative coordinates from `[-0.5, 0.5]`, e.g. `[0, 0]` corresponds to a point in the center of the viewport.
     */
    start?: Point.Point;
    /**
     * The position of the starting anchor, as a JSON string. Can either be an instance of a `Point` or a JSON string representation in the format of `[x, y]` or `{"x": 0, "y": 0}`.  Points are expected to be relative coordinates from `[-0.5, 0.5]`, e.g. `[0, 0]` corresponds to a point in the center of the viewport.
     */
    startJson?: string;
    /**
     * The viewer to connect to markups.  This property will automatically be set when a child of a `<vertex-viewer-markup>` or `<vertex-viewer>` element.
     */
    viewer?: HTMLVertexViewerElement;
  }
  interface VertexViewerMarkupCircle {
    /**
     * The bounds of the circle. Can either be an instance of a `Rectangle` or a JSON string representation in the format of `[x, y, width, height]` or `{"x": 0, "y": 0, "width": 10, "height": 10}`.  Bounds are expected to have relative coordinates, with `[x, y]` from `[-0.5, 0.5]` and `[width, height]` from `[0, 1]`, e.g. `[0, 0, 0.25, 0.25]`corresponds to a circle with a diameter of one fourth the viewport's smallest size in the center of the viewport.
     */
    bounds?: Rectangle.Rectangle;
    /**
     * The bounds of the circle. Can either be an instance of a `Rectangle` or a JSON string representation in the format of `[x, y, width, height]` or `{"x": 0, "y": 0, "width": 0.1, "height": 0.1}`.  Bounds are expected to have relative coordinates, with `[x, y]` from `[-0.5, 0.5]` and `[width, height]` from `[0, 1]`, e.g. `[0, 0, 0.25, 0.25]`corresponds to a circle with a diameter of one fourth the viewport's smallest size in the center of the viewport.
     */
    boundsJson?: string;
    /**
     * A mode that specifies how the markup component should behave. When unset, the component will not respond to interactions with the handles. When `edit`, the markup anchors are interactive and the user is able to reposition them. When `create`, anytime the user clicks on the canvas, a new markup will be performed.
     */
    mode?: ViewerMarkupCircleMode;
    /**
     * An event that is dispatched anytime the user begins editing the markup.
     */
    onEditBegin?: (event: CustomEvent<void>) => void;
    /**
     * An event that is dispatched when the user has finished editing the markup.
     */
    onEditEnd?: (event: CustomEvent<void>) => void;
    /**
     * An event that is dispatched when this markup element is in view mode (`this.mode === ""`), and it completes a rerender.
     */
    onViewRendered?: (event: CustomEvent<void>) => void;
    /**
     * The viewer to connect to markups.  This property will automatically be set when a child of a `<vertex-viewer-markup>` or `<vertex-viewer>` element.
     */
    viewer?: HTMLVertexViewerElement;
  }
  interface VertexViewerMarkupFreeform {
    /**
     * The bounds of the freeform. Can either be an instance of a `Rectangle` or a JSON string representation in the format of `[x, y, width, height]` or `{"x": 0, "y": 0, "width": 10, "height": 10}`.  Bounds are expected to have relative coordinates, with `[x, y]` from `[-0.5, 0.5]` and `[width, height]` from `[0, 1]`, e.g. `[0, 0, 0.25, 0.25]`corresponds to a freeform with a diameter of one fourth the viewport's smallest size in the center of the viewport.
     */
    bounds?: Rectangle.Rectangle;
    /**
     * The bounds of the freeform. Can either be an instance of a `Rectangle` or a JSON string representation in the format of `[x, y, width, height]` or `{"x": 0, "y": 0, "width": 0.1, "height": 0.1}`.  Bounds are expected to have relative coordinates, with `[x, y]` from `[-0.5, 0.5]` and `[width, height]` from `[0, 1]`, e.g. `[0, 0, 0.25, 0.25]`corresponds to a freeform with a diameter of one fourth the viewport's smallest size in the center of the viewport.
     */
    boundsJson?: string;
    /**
     * A mode that specifies how the markup component should behave. When unset, the component will not respond to interactions with the handles. When `edit`, the markup anchors are interactive and the user is able to reposition them. When `create`, anytime the user clicks on the canvas, a new markup will be performed.
     */
    mode?: ViewerMarkupFreeformMode;
    /**
     * An event that is dispatched anytime the user begins editing the markup.
     */
    onEditBegin?: (event: CustomEvent<void>) => void;
    /**
     * An event that is dispatched when the user has finished editing the markup.
     */
    onEditEnd?: (event: CustomEvent<void>) => void;
    /**
     * An event that is dispatched when this markup element is in view mode (`this.mode === ""`), and it completes a rerender.
     */
    onViewRendered?: (event: CustomEvent<void>) => void;
    /**
     * The positions of the various points of this freeform markup. Can either be an array of `Point`s or a JSON string representation in the format of `[[x1, y1], [x2, y2]]` or `[{"x": 0, "y": 0}, {"x": 0, "y": 0}]`.  Points are expected to be relative coordinates from `[-0.5, 0.5]`, e.g. `[0, 0]` corresponds to a point in the center of the viewport.
     */
    points?: Point.Point[];
    /**
     * The positions of the various points of this freeform markup. Can either be an array of `Point`s or a JSON string representation in the format of `[[x1, y1], [x2, y2]]` or `[{"x": 0, "y": 0}, {"x": 0, "y": 0}]`.  Points are expected to be relative coordinates from `[-0.5, 0.5]`, e.g. `[0, 0]` corresponds to a point in the center of the viewport.
     */
    pointsJson?: string;
    /**
     * The viewer to connect to markups.  This property will automatically be set when a child of a `<vertex-viewer-markup>` or `<vertex-viewer>` element.
     */
    viewer?: HTMLVertexViewerElement;
  }
  interface VertexViewerMarkupTool {
    /**
     * An HTML template that describes the HTML to use for new arrow markup. It's expected that the template contains a `<vertex-viewer-markup-arrow>`.
     */
    arrowTemplateId?: string;
    /**
     * An HTML template that describes the HTML to use for new circle markup. It's expected that the template contains a `<vertex-viewer-markup-circle>`.
     */
    circleTemplateId?: string;
    /**
     * Disables markups.  This property will automatically be set when a child of a `<vertex-viewer-markup>` element.
     */
    disabled?: boolean;
    /**
     * An HTML template that describes the HTML to use for new freeform markup. It's expected that the template contains a `<vertex-viewer-markup-freeform>`.
     */
    freeformTemplateId?: string;
    /**
     * An event that is dispatched when a user begins a new markup.
     */
    onMarkupBegin?: (event: CustomEvent<void>) => void;
    /**
     * An event that is dispatched when a user has finished their markup.
     */
    onMarkupEnd?: (event: CustomEvent<Markup>) => void;
    /**
     * The type of markup.  This property will automatically be set when a child of a `<vertex-viewer-markup>` element.
     */
    tool?: ViewerMarkupToolType;
    /**
     * The viewer to connect to markup.  This property will automatically be set when a child of a `<vertex-viewer-markup>` or `<vertex-viewer>` element.
     */
    viewer?: HTMLVertexViewerElement;
  }
  interface VertexViewerMeasurementDetails {
    /**
     * An optional formatter that can be used to format the display of an angle. The formatting function is passed a calculated angle in degrees and is expected to return a string.
     */
    angleFormatter?: Formatter<number>;
    /**
     * The unit of angle-based measurement.
     */
    angleUnits?: AngleUnitType;
    /**
     * An optional formatter that can be used to format the display of an area. The formatting function is passed a calculated area and is expected to return a string.
     */
    areaFormatter?: Formatter<number>;
    /**
     * An optional formatter that can be used to format the display of a distance. The formatting function is passed a calculated real-world distance and is expected to return a string.
     */
    distanceFormatter?: Formatter<number>;
    /**
     * The unit of distance-based measurement.
     */
    distanceUnits?: DistanceUnitType;
    /**
     * The number of fraction digits to display.
     */
    fractionalDigits?: number;
    /**
     * The `MeasurementModel` that should be reflected in these details. If not specified, a new `MeasurementModel` will be created, which can then be used to update the display.
     */
    measurementModel?: MeasurementModel;
    /**
     * The outcome to display. This property is automatically updated if a measurement model is provided.
     */
    measurementOutcome?: MeasurementOutcome;
    /**
     * The manager that the component will use to present measurement overlays.
     */
    measurementOverlays?: MeasurementOverlayManager;
    /**
     * A set of result types to display. If `undefined`, then all results will be displayed.
     */
    resultTypes?: MeasurementResult['type'][];
  }
  interface VertexViewerMeasurementDistance {
    /**
     * The distance from an anchor to its label.
     */
    anchorLabelOffset?: number;
    /**
     * The camera used to position the anchors. If `viewer` is defined, then the projection view matrix of the viewer will be used.
     */
    camera?: FrameCameraBase;
    /**
     * The distance between `start` and `end` in real world units. Value will be undefined if the start and end positions are undefined, or if the measurement is invalid.
     */
    distance?: number;
    /**
     * The position of the ending anchor. Can either be an instance of a `Vector3` or a JSON string representation in the format of `[x, y, z]` or `{"x": 0, "y": 0, "z": 0}`.
     */
    end?: Vector3.Vector3;
    /**
     * The position of the ending anchor, as a JSON string. Can either be an instance of a `Vector3` or a JSON string representation in the format of `[x, y, z]` or `{"x": 0, "y": 0, "z": 0}`.
     */
    endJson?: string;
    /**
     * The number of fraction digits to display.
     */
    fractionalDigits?: number;
    hitProvider?: PointToPointHitProvider;
    indicatorPt?: Vector3.Vector3;
    /**
     * A property that reflects which anchor is currently being interacted with.
     */
    interactingAnchor?: Anchor | 'none';
    /**
     * Indicates if the measurement is invalid. A measurement is invalid if either the start or end position are not on the surface of the model.
     */
    invalid?: boolean;
    /**
     * An optional formatter that can be used to format the display of a distance. The formatting function is passed a calculated real-world distance and is expected to return a string.
     */
    labelFormatter?: Formatter<number | undefined>;
    /**
     * The length of the caps at each end of the distance measurement.
     */
    lineCapLength?: number;
    /**
     * The measurement model that will be updated when this measurement changes. You can pass this to a <vertex-viewer-measurement-details> component to display measurement outcomes.
     */
    measurementModel?: MeasurementModel;
    /**
     * A mode that specifies how the measurement component should behave. When unset, the component will not respond to interactions with the handles. When `edit`, the measurement anchors are interactive and the user is able to reposition them. When `replace`, anytime the user clicks on the canvas, a new measurement will be performed.
     */
    mode?: ViewerMeasurementDistanceMode;
    /**
     * An event that is dispatched anytime the user begins editing the measurement.
     */
    onEditBegin?: (event: CustomEvent<EditBeginEventDetails>) => void;
    /**
     * An event that is dispatched when the user has finished editing the measurement.
     */
    onEditEnd?: (event: CustomEvent<EditEndEventDetails>) => void;
    /**
     * Enables the display of axis reference lines between the start and end point.
     */
    showAxisReferenceLines?: boolean;
    /**
     * The distance, in pixels, between the mouse and nearest snappable edge. A value of 0 disables snapping.
     */
    snapDistance?: number;
    /**
     * The position of the starting anchor. Can either be an instance of a `Vector3` or a JSON string representation in the format of `[x, y, z]` or `{"x": 0, "y": 0, "z": 0}`.
     */
    start?: Vector3.Vector3;
    /**
     * The position of the starting anchor, as a JSON string. Can either be an instance of a `Vector3` or a JSON string representation in the format of `[x, y, z]` or `{"x": 0, "y": 0, "z": 0}`.
     */
    startJson?: string;
    /**
     * The unit of measurement.
     */
    units?: DistanceUnitType;
    /**
     * The viewer to connect to this measurement. The measurement will redraw any time the viewer redraws the scene.
     */
    viewer?: HTMLVertexViewerElement;
  }
  interface VertexViewerMeasurementLine {
    /**
     * A length of the line cap. The line cap is a line at each end of a line.
     */
    capLength?: number;
    /**
     * A point that specifies the ending point of the line.
     */
    end?: Point.Point;
    /**
     * The type of [SVG pointer events](https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/pointer-events) that the line should respond to.
     */
    pointerEvents?: string;
    /**
     * A point that specifies the starting point of the line.
     */
    start?: Point.Point;
  }
  interface VertexViewerMeasurementOverlays {
    camera?: FrameCameraBase;
    /**
     * The model that contains the overlays to present.
     */
    measurementOverlays?: MeasurementOverlayManager;
    /**
     * The viewer that this component is bound to.
     */
    viewer?: HTMLVertexViewerElement;
  }
  interface VertexViewerMeasurementPrecise {
    /**
     * An optional configuration to setup network configuration of measurement endpoints.
     */
    config?: Config;
    /**
     * The environment that will be used to request measurement results.
     */
    configEnv?: Environment;
    measurableEntityTypes?: EntityType[];
    /**
     * The controller that is responsible for performing measurements and updating the model.
     */
    measurementController?: MeasurementController;
    /**
     * The model that contains the entities and outcomes from performing precise measurements.
     */
    measurementModel?: MeasurementModel;
    /**
     * The manager that is responsible for measurement overlays to present by this component.
     */
    measurementOverlays?: MeasurementOverlayManager;
    /**
     * The viewer that this component is bound to. This is automatically assigned if added to the light-dom of a parent viewer element.
     */
    viewer?: HTMLVertexViewerElement;
  }
  interface VertexViewerMeasurementTool {
    /**
     * Disables measurements.  This property will automatically be set when a child of a `<vertex-viewer-measurements>` element.
     */
    disabled?: boolean;
    /**
     * An ID to an HTML template that describes the HTML content to use for distance measurements. It's expected that the template contains a `<vertex-viewer-measurement-distance>`.  This property will automatically be set when a child of a `<vertex-viewer-measurements>` element.
     */
    distanceTemplateId?: string;
    /**
     * The number of fractional digits to display measurements in.
     */
    fractionalDigits?: number;
    /**
     * A property that indicates if the user is performing a measurement.
     */
    isMeasuring?: boolean;
    /**
     * An event that is dispatched when a user begins a new measurement.
     */
    onMeasureBegin?: (event: CustomEvent<void>) => void;
    /**
     * An event that is dispatched when a user has finished their measurement.
     */
    onMeasureEnd?: (event: CustomEvent<Measurement>) => void;
    /**
     * The distance, in pixels, between the mouse and nearest snappable edge. A value of 0 disables snapping.
     */
    snapDistance?: number;
    /**
     * The type of measurement.  This property will automatically be set when a child of a `<vertex-viewer-measurements>` element.
     */
    tool?: ViewerMeasurementToolType;
    /**
     * The unit type to display measurements in.
     */
    units?: DistanceUnitType;
    /**
     * The viewer to connect to measurements.  This property will automatically be set when a child of a `<vertex-viewer-measurements>` or `<vertex-viewer>` element.
     */
    viewer?: HTMLVertexViewerElement;
  }
  interface VertexViewerMeasurements {
    /**
     * If `true`, disables adding or editing of measurements through user interaction.
     */
    disabled?: boolean;
    /**
     * An HTML template that describes the HTML to use for new distance measurements. It's expected that the template contains a `<vertex-viewer-measurement-distance>`.
     */
    distanceTemplateId?: string;
    /**
     * The number of fractional digits to display measurements in.
     */
    fractionalDigits?: number;
    /**
     * The measurement model that will be updated with the selected measurement. You can pass this to a <vertex-viewer-measurement-details> component to display measurement outcomes.
     */
    measurementModel?: MeasurementModel;
    /**
     * Dispatched when a new measurement is added, either through user interaction or programmatically.
     */
    onMeasurementAdded?: (
      event: CustomEvent<HTMLVertexViewerMeasurementDistanceElement>
    ) => void;
    /**
     * Dispatched when a new measurement is removed, either through user interaction or programmatically.
     */
    onMeasurementRemoved?: (
      event: CustomEvent<HTMLVertexViewerMeasurementDistanceElement>
    ) => void;
    /**
     * The ID of the measurement that is selected.
     */
    selectedMeasurementId?: string;
    /**
     * Enables the display of axis reference lines between the start and end point of selected measurements.
     */
    showAxisReferenceLines?: boolean;
    /**
     * The distance, in pixels, between the mouse and nearest snappable edge. A value of 0 disables snapping.
     */
    snapDistance?: number;
    /**
     * The type of measurement to perform.
     */
    tool?: ViewerMeasurementToolType;
    /**
     * The unit type to display measurements in.
     */
    units?: DistanceUnitType;
    /**
     * The viewer to connect to measurements. If nested within a <vertex-viewer>, this property will be populated automatically.
     */
    viewer?: HTMLVertexViewerElement;
  }
  interface VertexViewerPinGroup {
    /**
     * The dimensions of the canvas for the pins
     */
    elementBounds?: DOMRect;
    /**
     * The local matrix of this element.
     */
    matrix?: Matrix4.Matrix4;
    /**
     * The pin to draw for the group
     */
    pin?: Pin;
    /**
     * The controller that drives behavior for pin operations
     */
    pinController?: PinController;
    /**
     * The model that contains the entities and outcomes from performing pin operations
     */
    pinModel?: PinModel;
    /**
     * Projection view matrix used for computing the position of the pin line
     */
    projectionViewMatrix?: Matrix4.Matrix4;
    /**
     * Whether or not the pin is "selected"
     */
    selected?: boolean;
  }
  interface VertexViewerPinLabel {
    /**
     * The dimensions of the canvas for the pins
     */
    elementBounds?: DOMRect;
    /**
     * Emitted whenever the label is blurred, with the ID of the associated pin (or undefined if no pin is provided).
     */
    onLabelBlurred?: (event: CustomEvent<string | undefined>) => void;
    onLabelChanged?: (event: CustomEvent<void>) => void;
    /**
     * Emitted whenever the label is focused, with the ID of the associated pin (or undefined if no pin is provided).
     */
    onLabelFocused?: (event: CustomEvent<string | undefined>) => void;
    /**
     * The pin to draw for the group
     */
    pin?: TextPin;
    /**
     * The controller that drives behavior for pin operations
     */
    pinController?: PinController;
    /**
     * The current text value of the component. Value is updated on user interaction.
     */
    value?: string;
  }
  interface VertexViewerPinLabelLine {
    labelPoint?: Point.Point | undefined;
    pinPoint?: Point.Point | undefined;
  }
  interface VertexViewerPinTool {
    /**
     * The mode of the pin tool
     */
    mode?: ViewerPinToolMode;
    /**
     * The controller that is responsible for drawing pins and updating the model
     */
    pinController?: PinController;
    /**
     * The model that contains the entities and outcomes from performing pin annotations
     */
    pinModel?: PinModel;
    pins?: Pin[];
    /**
     * The type of pin.  This property will automatically be set.
     */
    tool?: ViewerPinToolType;
    /**
     * The viewer that this component is bound to. This is automatically assigned if added to the light-dom of a parent viewer element.
     */
    viewer?: HTMLVertexViewerElement;
  }
  interface VertexViewerToolbar {
    direction?: ViewerToolbarDirection;
    /**
     * Specifies where the toolbar is positioned.
     */
    placement?: ViewerToolbarPlacement;
  }
  interface VertexViewerToolbarGroup {
    direction?: ViewerToolbarGroupDirection;
  }
  interface VertexViewerTransformWidget {
    /**
     * The controller that is responsible for performing transforms.
     */
    controller?: TransformController;
    /**
     * @ignore Visible for testing.
     */
    hovered?: Drawable;
    /**
     * An event that is emitted when the interaction has ended
     */
    onInteractionEnded?: (
      event: CustomEvent<Matrix4.Matrix4 | undefined>
    ) => void;
    /**
     * An event that is emitted an interaction with the widget has started
     */
    onInteractionStarted?: (event: CustomEvent<void>) => void;
    /**
     * An event that is emitted when the position of the widget changes.
     */
    onPositionChanged?: (
      event: CustomEvent<Vector3.Vector3 | undefined>
    ) => void;
    /**
     * The starting position of this transform widget. This position will be updated as transforms occur. Setting this value to `undefined` will remove the widget.
     */
    position?: Vector3.Vector3;
    /**
     * The viewer to connect to transforms. If nested within a <vertex-viewer>, this property will be populated automatically.
     */
    viewer?: HTMLVertexViewerElement;
  }
  interface VertexViewerViewCube {
    /**
     * The duration of the animation, in milliseconds, when a user performs a standard view interaction. Set to 0 to disable animations.
     */
    animationDuration?: number;
    camera?: FramePerspectiveCamera;
    /**
     * Disables interactions for standard views.
     */
    standardViewsOff?: boolean;
    /**
     * Disables the display of the triad.
     */
    triadOff?: boolean;
    /**
     * The viewer element that is connected to the view cube.
     */
    viewer?: HTMLVertexViewerElement;
    worldOrientation?: Orientation;
    /**
     * The label for the side of the cube on the negative x-axis.
     */
    xNegativeLabel?: string;
    /**
     * The label for the side of the cube on the positive x-axis.
     */
    xPositiveLabel?: string;
    /**
     * The label for the side of the cube on the negative y-axis.
     */
    yNegativeLabel?: string;
    /**
     * The label for the side of the cube on the positive y-axis.
     */
    yPositiveLabel?: string;
    /**
     * The label for the side of the cube on the negative z-axis.
     */
    zNegativeLabel?: string;
    /**
     * The label for the side of the cube on the positive z-axis.
     */
    zPositiveLabel?: string;
  }
  interface IntrinsicElements {
    'vertex-scene-tree': VertexSceneTree;
    'vertex-scene-tree-search': VertexSceneTreeSearch;
    'vertex-scene-tree-table-cell': VertexSceneTreeTableCell;
    'vertex-scene-tree-table-column': VertexSceneTreeTableColumn;
    'vertex-scene-tree-table-header': VertexSceneTreeTableHeader;
    'vertex-scene-tree-table-layout': VertexSceneTreeTableLayout;
    'vertex-scene-tree-table-resize-divider': VertexSceneTreeTableResizeDivider;
    'vertex-scene-tree-toolbar': VertexSceneTreeToolbar;
    'vertex-scene-tree-toolbar-group': VertexSceneTreeToolbarGroup;
    'vertex-viewer': VertexViewer;
    'vertex-viewer-button': VertexViewerButton;
    'vertex-viewer-default-toolbar': VertexViewerDefaultToolbar;
    'vertex-viewer-dom-element': VertexViewerDomElement;
    'vertex-viewer-dom-group': VertexViewerDomGroup;
    'vertex-viewer-dom-renderer': VertexViewerDomRenderer;
    'vertex-viewer-icon': VertexViewerIcon;
    'vertex-viewer-layer': VertexViewerLayer;
    'vertex-viewer-markup': VertexViewerMarkup;
    'vertex-viewer-markup-arrow': VertexViewerMarkupArrow;
    'vertex-viewer-markup-circle': VertexViewerMarkupCircle;
    'vertex-viewer-markup-freeform': VertexViewerMarkupFreeform;
    'vertex-viewer-markup-tool': VertexViewerMarkupTool;
    'vertex-viewer-measurement-details': VertexViewerMeasurementDetails;
    'vertex-viewer-measurement-distance': VertexViewerMeasurementDistance;
    'vertex-viewer-measurement-line': VertexViewerMeasurementLine;
    'vertex-viewer-measurement-overlays': VertexViewerMeasurementOverlays;
    'vertex-viewer-measurement-precise': VertexViewerMeasurementPrecise;
    'vertex-viewer-measurement-tool': VertexViewerMeasurementTool;
    'vertex-viewer-measurements': VertexViewerMeasurements;
    'vertex-viewer-pin-group': VertexViewerPinGroup;
    'vertex-viewer-pin-label': VertexViewerPinLabel;
    'vertex-viewer-pin-label-line': VertexViewerPinLabelLine;
    'vertex-viewer-pin-tool': VertexViewerPinTool;
    'vertex-viewer-toolbar': VertexViewerToolbar;
    'vertex-viewer-toolbar-group': VertexViewerToolbarGroup;
    'vertex-viewer-transform-widget': VertexViewerTransformWidget;
    'vertex-viewer-view-cube': VertexViewerViewCube;
  }
}
export { LocalJSX as JSX };
declare module '@stencil/core' {
  export namespace JSX {
    interface IntrinsicElements {
      'vertex-scene-tree': LocalJSX.VertexSceneTree &
        JSXBase.HTMLAttributes<HTMLVertexSceneTreeElement>;
      'vertex-scene-tree-search': LocalJSX.VertexSceneTreeSearch &
        JSXBase.HTMLAttributes<HTMLVertexSceneTreeSearchElement>;
      'vertex-scene-tree-table-cell': LocalJSX.VertexSceneTreeTableCell &
        JSXBase.HTMLAttributes<HTMLVertexSceneTreeTableCellElement>;
      'vertex-scene-tree-table-column': LocalJSX.VertexSceneTreeTableColumn &
        JSXBase.HTMLAttributes<HTMLVertexSceneTreeTableColumnElement>;
      'vertex-scene-tree-table-header': LocalJSX.VertexSceneTreeTableHeader &
        JSXBase.HTMLAttributes<HTMLVertexSceneTreeTableHeaderElement>;
      'vertex-scene-tree-table-layout': LocalJSX.VertexSceneTreeTableLayout &
        JSXBase.HTMLAttributes<HTMLVertexSceneTreeTableLayoutElement>;
      'vertex-scene-tree-table-resize-divider': LocalJSX.VertexSceneTreeTableResizeDivider &
        JSXBase.HTMLAttributes<HTMLVertexSceneTreeTableResizeDividerElement>;
      'vertex-scene-tree-toolbar': LocalJSX.VertexSceneTreeToolbar &
        JSXBase.HTMLAttributes<HTMLVertexSceneTreeToolbarElement>;
      'vertex-scene-tree-toolbar-group': LocalJSX.VertexSceneTreeToolbarGroup &
        JSXBase.HTMLAttributes<HTMLVertexSceneTreeToolbarGroupElement>;
      'vertex-viewer': LocalJSX.VertexViewer &
        JSXBase.HTMLAttributes<HTMLVertexViewerElement>;
      'vertex-viewer-button': LocalJSX.VertexViewerButton &
        JSXBase.HTMLAttributes<HTMLVertexViewerButtonElement>;
      'vertex-viewer-default-toolbar': LocalJSX.VertexViewerDefaultToolbar &
        JSXBase.HTMLAttributes<HTMLVertexViewerDefaultToolbarElement>;
      'vertex-viewer-dom-element': LocalJSX.VertexViewerDomElement &
        JSXBase.HTMLAttributes<HTMLVertexViewerDomElementElement>;
      'vertex-viewer-dom-group': LocalJSX.VertexViewerDomGroup &
        JSXBase.HTMLAttributes<HTMLVertexViewerDomGroupElement>;
      'vertex-viewer-dom-renderer': LocalJSX.VertexViewerDomRenderer &
        JSXBase.HTMLAttributes<HTMLVertexViewerDomRendererElement>;
      'vertex-viewer-icon': LocalJSX.VertexViewerIcon &
        JSXBase.HTMLAttributes<HTMLVertexViewerIconElement>;
      'vertex-viewer-layer': LocalJSX.VertexViewerLayer &
        JSXBase.HTMLAttributes<HTMLVertexViewerLayerElement>;
      'vertex-viewer-markup': LocalJSX.VertexViewerMarkup &
        JSXBase.HTMLAttributes<HTMLVertexViewerMarkupElement>;
      'vertex-viewer-markup-arrow': LocalJSX.VertexViewerMarkupArrow &
        JSXBase.HTMLAttributes<HTMLVertexViewerMarkupArrowElement>;
      'vertex-viewer-markup-circle': LocalJSX.VertexViewerMarkupCircle &
        JSXBase.HTMLAttributes<HTMLVertexViewerMarkupCircleElement>;
      'vertex-viewer-markup-freeform': LocalJSX.VertexViewerMarkupFreeform &
        JSXBase.HTMLAttributes<HTMLVertexViewerMarkupFreeformElement>;
      'vertex-viewer-markup-tool': LocalJSX.VertexViewerMarkupTool &
        JSXBase.HTMLAttributes<HTMLVertexViewerMarkupToolElement>;
      'vertex-viewer-measurement-details': LocalJSX.VertexViewerMeasurementDetails &
        JSXBase.HTMLAttributes<HTMLVertexViewerMeasurementDetailsElement>;
      'vertex-viewer-measurement-distance': LocalJSX.VertexViewerMeasurementDistance &
        JSXBase.HTMLAttributes<HTMLVertexViewerMeasurementDistanceElement>;
      'vertex-viewer-measurement-line': LocalJSX.VertexViewerMeasurementLine &
        JSXBase.HTMLAttributes<HTMLVertexViewerMeasurementLineElement>;
      'vertex-viewer-measurement-overlays': LocalJSX.VertexViewerMeasurementOverlays &
        JSXBase.HTMLAttributes<HTMLVertexViewerMeasurementOverlaysElement>;
      'vertex-viewer-measurement-precise': LocalJSX.VertexViewerMeasurementPrecise &
        JSXBase.HTMLAttributes<HTMLVertexViewerMeasurementPreciseElement>;
      'vertex-viewer-measurement-tool': LocalJSX.VertexViewerMeasurementTool &
        JSXBase.HTMLAttributes<HTMLVertexViewerMeasurementToolElement>;
      'vertex-viewer-measurements': LocalJSX.VertexViewerMeasurements &
        JSXBase.HTMLAttributes<HTMLVertexViewerMeasurementsElement>;
      'vertex-viewer-pin-group': LocalJSX.VertexViewerPinGroup &
        JSXBase.HTMLAttributes<HTMLVertexViewerPinGroupElement>;
      'vertex-viewer-pin-label': LocalJSX.VertexViewerPinLabel &
        JSXBase.HTMLAttributes<HTMLVertexViewerPinLabelElement>;
      'vertex-viewer-pin-label-line': LocalJSX.VertexViewerPinLabelLine &
        JSXBase.HTMLAttributes<HTMLVertexViewerPinLabelLineElement>;
      'vertex-viewer-pin-tool': LocalJSX.VertexViewerPinTool &
        JSXBase.HTMLAttributes<HTMLVertexViewerPinToolElement>;
      'vertex-viewer-toolbar': LocalJSX.VertexViewerToolbar &
        JSXBase.HTMLAttributes<HTMLVertexViewerToolbarElement>;
      'vertex-viewer-toolbar-group': LocalJSX.VertexViewerToolbarGroup &
        JSXBase.HTMLAttributes<HTMLVertexViewerToolbarGroupElement>;
      'vertex-viewer-transform-widget': LocalJSX.VertexViewerTransformWidget &
        JSXBase.HTMLAttributes<HTMLVertexViewerTransformWidgetElement>;
      'vertex-viewer-view-cube': LocalJSX.VertexViewerViewCube &
        JSXBase.HTMLAttributes<HTMLVertexViewerViewCubeElement>;
    }
  }
}
