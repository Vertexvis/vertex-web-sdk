/* eslint-disable */
/* tslint:disable */
/**
 * This is an autogenerated file created by the Stencil compiler.
 * It contains typing information for all components that exist in this project.
 */
import { HTMLStencilElement, JSXBase } from '@stencil/core/internal';
import {
  MetadataKey,
  RowArg,
  RowDataProvider,
  SceneTreeOperationOptions,
  ScrollToOptions,
  SelectItemOptions,
} from './components/scene-tree/types';
import { Config, PartialConfig } from './lib/config';
import { Environment } from './lib/environment';
import {
  FilterTreeOptions,
  SceneTreeController,
} from './components/scene-tree/lib/controller';
import { SceneTreeErrorDetails } from './components/scene-tree/lib/errors';
import { Row } from './components/scene-tree/lib/row';
import { Node } from '@vertexvis/scene-tree-protos/scenetree/protos/domain_pb';
import { SceneTreeOperationHandler } from './components/scene-tree/lib/handlers';
import { SceneTreeCellHoverController } from './components/scene-tree-table-layout/lib/hover-controller';
import { SceneTreeTableCellEventDetails } from './components/scene-tree-table-cell/scene-tree-table-cell';
import { DomScrollToOptions } from './components/scene-tree-table-layout/lib/dom';
import { FrameCameraType } from './lib/types/frameCamera';
import {
  FeatureHighlightOptions,
  FeatureLineOptions,
  FrameType,
  PhantomOptions,
  SelectionHighlightingOptions,
} from './interfaces';
import { Frame, FrameCameraBase } from './lib/types/frame';
import { ViewerStream } from './lib/stream/stream';
import {
  AngleUnitType,
  DepthBuffer,
  DistanceUnitType,
  EntityType,
  FrameCameraBase as FrameCameraBase1,
  FramePerspectiveCamera,
  Orientation,
  StencilBufferManager,
  Viewport,
} from './lib/types';
import { TapEventDetails } from './lib/interactions/tapEventDetails';
import { ConnectionStatus } from './components/viewer/viewer';
import {
  Dimensions,
  Euler,
  Matrix4,
  Point,
  Quaternion,
  Rectangle,
  Vector3,
} from '@vertexvis/geometry';
import { Color, Disposable } from '@vertexvis/utils';
import { InteractionHandler } from './lib/interactions/interactionHandler';
import { KeyInteraction } from './lib/interactions/keyInteraction';
import { Cursor } from './lib/cursors';
import { BaseInteractionHandler } from './lib/interactions/baseInteractionHandler';
import { Scene } from './lib/scenes/scene';
import { VolumeIntersectionQueryController } from './lib/volume-intersection/controller';
import { VolumeIntersectionQueryModel } from './lib/volume-intersection/model';
import {
  VolumeIntersectionQueryMode,
  VolumeIntersectionQueryType,
} from './components/viewer-box-query-tool/types';
import {
  ViewerToolbarDirection,
  ViewerToolbarPlacement,
} from './components/viewer-toolbar/types';
import { ViewerToolbarGroupDirection } from './components/viewer-toolbar-group/types';
import { ViewerDomRendererDrawMode } from './components/viewer-dom-renderer/viewer-dom-renderer';
import {
  ViewerIconName,
  ViewerIconSize,
} from './components/viewer-icon/viewer-icon';
import { ViewerMarkupToolType } from './components/viewer-markup-tool/viewer-markup-tool';
import { Markup } from './lib/types/markup';
import { ViewerMarkupArrowMode } from './components/viewer-markup-arrow/viewer-markup-arrow';
import { ViewerMarkupCircleMode } from './components/viewer-markup-circle/viewer-markup-circle';
import { ViewerMarkupFreeformMode } from './components/viewer-markup-freeform/viewer-markup-freeform';
import { ViewerMarkupToolType as ViewerMarkupToolType1 } from './components/viewer-markup-tool/viewer-markup-tool';
import {
  MeasurementController,
  MeasurementModel,
  MeasurementOutcome,
  MeasurementOverlayManager,
  MeasurementResult,
} from './lib/measurement';
import { Formatter } from './lib/formatter';
import {
  EditBeginEventDetails,
  EditEndEventDetails,
  ViewerMeasurementDistanceElementMetrics,
  ViewerMeasurementDistanceMode,
} from './components/viewer-measurement-distance/viewer-measurement-distance';
import { Anchor } from './components/viewer-measurement-distance/utils';
import { PointToPointHitProvider } from './components/viewer-measurement-distance/interactions';
import {
  Pin,
  PinModel,
  TextPin,
  ViewerPinToolMode,
  ViewerPinToolType,
} from './lib/pins/model';
import { PinController } from './lib/pins/controller';
import { SpinnerSize } from './components/viewer-spinner/viewer-spinner';
import { ViewerTeleportMode, WalkModeModel } from './lib/walk-mode/model';
import { WalkModeController } from './lib/walk-mode/controller';
import { TransformController } from './lib/transforms/controller';
import { Drawable } from './lib/transforms/drawable';
export namespace Components {
  interface VertexSceneTree {
    /**
     * Performs an API call to collapse all nodes in the tree.
     */
    collapseAll: () => Promise<void>;
    /**
     * Performs an API call that will collapse the node associated to the specified row or row index.
     * @param row A row, row index, or node to collapse.
     */
    collapseItem: (row: RowArg) => Promise<void>;
    /**
     * An object to configure the scene tree.
     */
    config?: PartialConfig | string;
    /**
     * Sets the default environment for the viewer. This setting is used for auto-configuring network hosts.  Use the `config` property for manually setting hosts.
     */
    configEnv: Environment;
    controller?: SceneTreeController;
    /**
     * Performs an API call that will deselect the item associated to the given row or row index.
     * @param row The row, row index, or node to deselect.
     */
    deselectItem: (row: RowArg) => Promise<void>;
    /**
     * Performs an API call to expand all nodes in the tree.
     */
    expandAll: () => Promise<void>;
    /**
     * Performs an API call that will expand the node associated to the specified row or row index.
     * @param row A row, row index, or node to expand.
     */
    expandItem: (row: RowArg) => Promise<void>;
    /**
     * Fetches the metadata keys that are available to the scene tree. Metadata keys can be assigned to the scene tree using the `metadataKeys` property. The scene tree will fetch this metadata and make these values available for data binding.
     * @returns A promise that resolves with the names of available keys.
     */
    fetchMetadataKeys: () => Promise<MetadataKey[]>;
    /**
     * Performs an async request that will filter the displayed items in the tree that match the given term and options.
     * @param term The filter term.
     * @param options The options to apply to the filter.
     * @returns A promise that completes when the request has completed. Note, items are displayed asynchronously. So the displayed items may not reflect the result of this filter when the promise completes.
     */
    filterItems: (term: string, options?: FilterTreeOptions) => Promise<void>;
    /**
     * Returns the row data from the given vertical client position.
     * @param clientY The vertical client position.
     * @returns A row or `undefined` if the row hasn't been loaded.
     */
    getRowAtClientY: (clientY: number) => Promise<Row>;
    /**
     * Returns a row at the given index. If the row data has not been loaded, returns `undefined`.
     * @param index The index of the row.
     * @returns A row, or `undefined` if the row hasn't been loaded.
     */
    getRowAtIndex: (index: number) => Promise<Row>;
    /**
     * Returns the row data from the given mouse or pointer event. The event must originate from a `vertex-scene-tree-table-cell` contained by this element, otherwise `undefined` is returned.
     * @param event A mouse or pointer event that originated from this component.
     * @returns A row, or `undefined` if the row hasn't been loaded.
     */
    getRowForEvent: (event: MouseEvent | PointerEvent) => Promise<Row>;
    /**
     * Performs an API call that will hide the item associated to the given row or row index.
     * @param row The row, row index, or node to hide.
     */
    hideItem: (row: RowArg) => Promise<void>;
    /**
     * Schedules a render of the rows in the scene tree. Useful if any custom data in your scene tree has changed, and you want to update the row's contents.  **Note:** This is an asynchronous operation. The update may happen on the next frame.
     */
    invalidateRows: () => Promise<void>;
    /**
     * A list of part metadata keys that will be made available to each row. This metadata can be used for data binding inside the scene tree's template.
     */
    metadataKeys: MetadataKey[];
    /**
     * Indicates whether the metadata search should use an exact match.
     */
    metadataSearchExactMatch: boolean;
    /**
     * A list of the metadata keys that a scene tree search should be performed on.
     */
    metadataSearchKeys: MetadataKey[];
    /**
     * The number of offscreen rows above and below the viewport to render. Having a higher number reduces the chance of the browser not displaying a row while scrolling.
     */
    overScanCount: number;
    /**
     * A callback that is invoked immediately before a row is about to rendered. This callback can return additional data that can be bound to in a template.
     * @example ```html <script>   const table = document.querySelector('vertex-scene-tree-table');   table.rowData = (row) => {     return { func: () => console.log('row', row.node.name) };   } </script>  <vertex-scene-tree>  <vertex-scene-tree-table>    <vertex-scene-tree-table-column>      <template>        <button event:click="{{row.data.func}}">Hi</button>      </template>    </vertex-scene-tree-table-column>  </vertex-scene-tree-table> </vertex-scene-tree> ```
     */
    rowData?: RowDataProvider;
    /**
     * Scrolls the tree to the given row index.
     * @param index An index of the row to scroll to.
     * @param options A set of options to configure the scrolling behavior.
     */
    scrollToIndex: (index: number, options?: ScrollToOptions) => Promise<void>;
    /**
     * Scrolls the tree to an item with the given ID. If the node for the item is not expanded, the tree will expand each of its parent nodes.
     * @param itemId An ID of an item to scroll to.
     * @param options A set of options to configure the scrolling behavior.
     * @returns A promise that resolves when the operation is finished.
     */
    scrollToItem: (itemId: string, options?: ScrollToOptions) => Promise<void>;
    /**
     * Performs an async request that will select the filtered items in the tree that match the given term.
     * @param term The filter term.
     * @returns A promise that completes when the request has completed.
     */
    selectFilteredItems: (
      term: string,
      options?: SceneTreeOperationOptions | undefined
    ) => Promise<void>;
    /**
     * Performs an API call that will select the item associated to the given row or row index.  This method supports a `recurseParent` option that allows for recursively selecting the next unselected parent node. This behavior is considered stateful. Each call to `selectItem` will track the ancestry of the passed in `rowArg`. If calling `selectItem` with a row not belonging to the ancestry of a previous selection, then this method will perform a standard selection.
     * @param row The row, row index or node to select.
     * @param options A set of options to configure selection behavior.
     */
    selectItem: (
      row: RowArg,
      { recurseParent, ...options }?: SelectItemOptions
    ) => Promise<void>;
    /**
     * Performs an API call that will show the item associated to the given row or row index.
     * @param row The row, row index, or node to show.
     */
    showItem: (row: RowArg) => Promise<void>;
    /**
     * Performs an API call that will either expand or collapse the node associated to the given row or row index.
     * @param row The row, row index, or node to collapse or expand.
     */
    toggleExpandItem: (row: RowArg) => Promise<void>;
    /**
     * Performs an API call that will either hide or show the item associated to the given row or row index.
     * @param row The row, row index, or node to toggle visibility.
     */
    toggleItemVisibility: (row: RowArg) => Promise<void>;
    /**
     * An instance of a `<vertex-viewer>` element. Either this property or `viewerSelector` must be set.
     */
    viewer?: HTMLVertexViewerElement | null;
    /**
     * A CSS selector that points to a `<vertex-viewer>` element. Either this property or `viewer` must be set.
     */
    viewerSelector?: string;
  }
  interface VertexSceneTreeSearch {
    /**
     * The scene tree controller
     */
    controller?: SceneTreeController;
    /**
     * Specifies the delay, in milliseconds, to emit `search` events after user input.
     */
    debounce: number;
    /**
     * If `true`, disables user interaction of the component.
     */
    disabled: boolean;
    /**
     * Placeholder text if `value` is empty.
     */
    placeholder?: string;
    /**
     * Gives focus to the the component's internal text input.
     */
    setFocus: () => Promise<void>;
    /**
     * The current text value of the component. Value is updated on user interaction.
     */
    value: string;
  }
  interface VertexSceneTreeTableCell {
    /**
     * Indicates whether to display a button for toggling the expanded state of the node associated with this cell.
     */
    expandToggle?: boolean;
    /**
     * An optional handler that will override this cell's default expansion behavior. The registered handler will receive the `pointerup` event, the node data for the row this cell is associated with, and a reference to the parent `<vertex-scene-tree>` element for performing operations.
     */
    expansionHandler?: SceneTreeOperationHandler;
    hoverController?: SceneTreeCellHoverController;
    hovered: boolean;
    isScrolling?: boolean;
    /**
     * The node data that is associated to the row that this cell belongs to. Contains information related to if the node is expanded, visible, etc.
     */
    node?: Node.AsObject;
    /**
     * The value to display in this cell if the `value` specified is undefined. Defaults to "--".
     */
    placeholder: string;
    /**
     * An optional handler that will override this cell's default selection behavior. The registered handler will receive the `pointerup` event, the node data for the row this cell is associated with, and a reference to the parent `<vertex-scene-tree>` element for performing operations.
     */
    selectionHandler?: SceneTreeOperationHandler;
    /**
     * A reference to the scene tree to perform operations for interactions. Such as expansion, visibility and selection.
     */
    tree?: HTMLVertexSceneTreeElement;
    /**
     * The value to display in this cell.
     */
    value?: string;
    /**
     * An optional handler that will override this cell's default visibility behavior. The registered handler will receive the `pointerup` event, the node data for the row this cell is associated with, and a reference to the parent `<vertex-scene-tree>` element for performing operations.
     */
    visibilityHandler?: SceneTreeOperationHandler;
    /**
     * Indicates whether to display a button for toggling the visibility state of the node associated with this cell.
     */
    visibilityToggle?: boolean;
  }
  interface VertexSceneTreeTableColumn {
    /**
     * The initial width of this column.
     */
    initialWidth?: number;
    /**
     * The maximum width of this column.
     */
    maxWidth?: number;
    /**
     * The minimum width of this column.
     */
    minWidth?: number;
  }
  interface VertexSceneTreeTableHeader {}
  interface VertexSceneTreeTableLayout {
    controller?: SceneTreeController;
    layoutHeight?: number;
    layoutOffset: number;
    layoutWidth?: number;
    /**
     * The number of offscreen rows above and below the viewport to render. Having a higher number reduces the chance of the browser not displaying a row while scrolling.  This prop will be automatically populated based on the `overScanCount` prop specified in the parent `<vertex-scene-tree />` element.
     */
    overScanCount: number;
    /**
     * A callback that is invoked immediately before a row is about to rendered. This callback can return additional data that can be bound to in a template.  This prop will be automatically populated based on the `rowData` prop specified in the parent `<vertex-scene-tree />` element.
     * @example ```html <script>   const table = document.querySelector('vertex-scene-tree-table');   table.rowData = (row) => {     return { func: () => console.log('row', row.node.name) };   } </script>  <vertex-scene-tree>  <vertex-scene-tree-table>    <vertex-scene-tree-table-column>      <template>        <button event:click="{{row.data.func}}">Hi</button>      </template>    </vertex-scene-tree-table-column>  </vertex-scene-tree-table> </vertex-scene-tree> ```
     */
    rowData?: RowDataProvider;
    rowHeight: number;
    rows: Row[];
    scrollOffset: number;
    /**
     * Scrolls the table to the provided top value.
     * @param top The position to scroll to.
     * @param options A set of options to configure the scrolling behavior.
     */
    scrollToPosition: (
      top: number,
      options: Pick<DomScrollToOptions, 'behavior'>
    ) => Promise<void>;
    totalRows: number;
    /**
     * A reference to the scene tree to perform operations for interactions. Such as expansion, visibility and selection.
     */
    tree?: HTMLVertexSceneTreeElement;
    viewportEndIndex: number;
    viewportStartIndex: number;
  }
  interface VertexSceneTreeTableResizeDivider {}
  interface VertexSceneTreeToolbar {}
  interface VertexSceneTreeToolbarGroup {}
  interface VertexViewer {
    /**
     * Adds a cursor to the viewer, and displays it if the cursor has the highest priority.  Cursors are managed as a prioritized list. A cursor is displayed if it has the highest priority or if the cursor is the most recently added cursor in the set of cursors with the same priority.  To remove a cursor, call `dispose()` on the returned disposable.
     * @param cursor The cursor to add.
     * @param priority The priority of the cursor.
     * @returns A disposable that can be used to remove the cursor.
     * @see See {@link CursorManager} for constants to pass to `priority`.
     */
    addCursor: (
      cursor: Cursor,
      priority?: number | undefined
    ) => Promise<Disposable>;
    /**
     * Enables or disables the default mouse and touch interactions provided by the viewer. Enabled by default.
     */
    cameraControls: boolean;
    /**
     * The type of camera model to represent the scene with. Can be either `perspective` or `orthographic`, and defaults to `perspective`.
     */
    cameraType: FrameCameraType;
    /**
     * The Client ID associated with your Vertex Application.
     */
    clientId?: string;
    /**
     * An object or JSON encoded string that defines configuration settings for the viewer.
     */
    config?: PartialConfig | string;
    /**
     * Sets the default environment for the viewer. This setting is used for auto-configuring network hosts.  Use the `config` property for manually setting hosts.
     * @see Viewer.config
     */
    configEnv: Environment;
    /**
     * Specifies when a depth buffer is requested from rendering. Possible values are:  * `undefined`: A depth buffer is never requested. * `final`: A depth buffer is only requested on the final frame. * `all`: A depth buffer is requested for every frame.  Depth buffers can increase the amount of data that's sent to a client and can impact rendering performance. Values of `undefined` or `final` should be used when needing the highest rendering performance.
     */
    depthBuffers?: FrameType;
    /**
     * Property used for internals or testing.
     * @private
     */
    deviceId?: string;
    dispatchFrameDrawn: (frame: Frame) => Promise<void>;
    /**
     * @private
     */
    experimentalRenderingOptions: string;
    /**
     * Specifies how selected features should be highlighted.
     */
    featureHighlighting?: FeatureHighlightOptions;
    /**
     * Specifies if and how to render feature lines.
     */
    featureLines?: FeatureLineOptions;
    /**
     * Specifies when a feature map is returned from rendering. Feature maps include information about the surfaces, edges and cross sections that are in a frame.  Possible values are:  * `undefined`: A feature map is never requested. * `final`: A feature map is only requested on the final frame. * `all`: A feature map is requested for every frame.  Feature maps can increase the amount of data that's sent to a client and can impact rendering performance. Values of `undefined` or `final` should be used when needing the highest rendering performance.
     */
    featureMaps?: FrameType;
    /**
     * The last frame that was received, which can be used to inspect the scene and camera information.
     * @readonly
     */
    frame: Frame | undefined;
    getBaseInteractionHandler: () => Promise<
      BaseInteractionHandler | undefined
    >;
    getInteractionHandlers: () => Promise<InteractionHandler[]>;
    /**
     * The HTML element that will handle interaction events from the user. Used by components to listen for interaction events from the same element as the viewer. Note, this property maybe removed in the future when refactoring our interaction handling.
     * @deprecated Use `InteractionHandler`.
     */
    getInteractionTarget_DEPRECATED: () => Promise<HTMLElement>;
    /**
     * @deprecated Use `token`.
     */
    getJwt: () => Promise<string | undefined>;
    /**
     * @ignore
     */
    getKeyInteractions: () => Promise<KeyInteraction<TapEventDetails>[]>;
    /**
     * Returns `true` indicating that the scene is ready to be interacted with.
     */
    isSceneReady: () => Promise<boolean>;
    /**
     * Enables or disables the default keyboard shortcut interactions provided by the viewer. Enabled by default, requires `cameraControls` being enabled.
     */
    keyboardControls: boolean;
    /**
     * Loads the given scene into the viewer and return a `Promise` that resolves when the scene has been loaded. The specified scene is provided as a URN in the following format:   * `urn:vertex:scene:<sceneid>`
     * @param urn The URN of the resource to load.
     */
    load: (urn: string) => Promise<void>;
    /**
     * Specifies whether to use the default lights for the scene. When false, default lights are used. When true, no default lights are used, and the lights must be specified separately.
     */
    noDefaultLights: boolean;
    /**
     * Specifies how phantom parts should appear. The opacity must be between 0 and 1, where 0 is completely hidden and 1 is completely visible.
     */
    phantom?: PhantomOptions;
    /**
     * Registers and initializes an interaction handler with the viewer. Returns a `Disposable` that should be used to deregister the interaction handler.  `InteractionHandler`s are used to build custom mouse and touch interactions for the viewer. Use `<vertex-viewer camera-controls="false" />` to disable the default camera controls provided by the viewer.
     * @example
     * ```
     * class CustomInteractionHandler extends InteractionHandler {
     *   private element: HTMLElement;
     *   private api: InteractionApi;
     *   public dispose(): void {
     *     this.element.removeEventListener('click', this.handleElementClick);
     *   }
     *   public initialize(element: HTMLElement, api: InteractionApi): void {
     *     this.api = api;
     *     this.element = element;
     *     this.element.addEventListener('click', this.handleElementClick);
     *   }
     *   private handleElementClick = (event: MouseEvent) => {
     *     api.tap({ x: event.clientX, y: event.clientY });
     *   };
     * }
     * const viewer = document.querySelector('vertex-viewer');
     * viewer.registerInteractionHandler(new CustomInteractionHandler());
     * ```
     * @param interactionHandler The interaction handler to register.
     * @returns A promise containing the disposable to use to deregister the handler.
     */
    registerInteractionHandler: (
      interactionHandler: InteractionHandler
    ) => Promise<Disposable>;
    /**
     * Registers a key interaction to be invoked when a specific set of keys are pressed during a `tap` event.  `KeyInteraction`s are used to build custom keyboard shortcuts for the viewer using the current state of they keyboard to determine whether the `fn` should be invoked. Use `<vertex-viewer keyboard-controls="false" />` to disable the default keyboard shortcuts provided by the viewer.
     * @example
     * ```
     * class CustomKeyboardInteraction extends KeyInteraction<TapEventDetails> {
     *   constructor(private viewer: HTMLVertexViewerElement) {}
     *   public predicate(keyState: KeyState): boolean {
     *     return keyState['Alt'];
     *   }
     *   public async fn(event: TapEventDetails) {
     *     const scene = await this.viewer.scene();
     *     const result = await scene.raycaster().hitItems(event.position);
     *     if (result.hits.length > 0) {
     *       await scene
     *         .camera()
     *         .fitTo((q) => q.withItemId(result.hits[0].itemId))
     *         .render();
     *     }
     *   }
     * }
     * ```
     * @param keyInteraction - The `KeyInteraction` to register.
     */
    registerTapKeyInteraction: (
      keyInteraction: KeyInteraction<TapEventDetails>
    ) => Promise<void>;
    /**
     * An optional value that will debounce frame updates when resizing this viewer element.
     */
    resizeDebounce: number;
    resolvedConfig?: Config;
    /**
     * Enables or disables the default rotation interaction being changed to rotate around the pointer down location.
     */
    rotateAroundTapPoint: boolean;
    /**
     * Returns an object that is used to perform operations on the `Scene` that's currently being viewed. These operations include updating items, positioning the camera and performing hit tests.
     */
    scene: () => Promise<Scene>;
    /**
     * Specifies the halo selection properties. Parameter notes:  lineWidth values supported currently are 0-5. This width is currently the value x2. For example, 1 will have a pixel width of 2.  color is optional. This will be the color of the selected items in the viewer.  opacity is also optional. The opacity will be applied to everything selected besides the highlighted outer line.
     */
    selectionHighlighting?: SelectionHighlightingOptions;
    /**
     * A URN of the scene resource to load when the component is mounted in the DOM tree. The specified resource is a URN in the following format:   * `urn:vertex:scene:<sceneid>`
     */
    src?: string;
    stencilBuffer: StencilBufferManager;
    stream?: ViewerStream;
    /**
     * A token that can be used to make API calls to other Vertex services.
     */
    token?: string;
    /**
     * Disconnects the websocket and removes any internal state associated with the scene.
     */
    unload: () => Promise<void>;
    /**
     * Represents the current viewport of the viewer. The viewport represents the dimensions of the canvas where a frame is rendered. It contains methods for translating between viewport coordinates, frame coordinates and world coordinates.
     */
    viewport: Viewport;
  }
  interface VertexViewerBoxQueryTool {
    /**
     * The controller that is responsible for performing operations using the volume intersection query defined by the drawn box and updating the model.
     */
    controller?: VolumeIntersectionQueryController;
    /**
     * An optional value to specify a singular mode of intersection query. This value defaults to `undefined`, which will indicate that both `exclusive` and `inclusive` queries should be made, with `inclusive` being represented by a left to right drag behavior and `exclusive` being represented by a right to left drag.  Setting this value to `inclusive` will cause dragging left to right and left to right to result in an `inclusive` query, and the box will only be styled for `inclusive` queries.  Setting this value to `exclusive` will cause dragging left to right and left to right to result in an `exclusive` query, and the box will only be styled for `exclusive` queries.
     */
    mode?: VolumeIntersectionQueryMode;
    /**
     * The model that contains the points representing the corners of the box displayed on screen, the type of the query to be performed, and methods for setting these values.
     */
    model?: VolumeIntersectionQueryModel;
    /**
     * The default operation to perform when a drag has completed and the intersection query will be run. Defaults to `clearAndSelect`, and can be changed to `select` or `deselect`.  `clearAndSelect` will clear all existing selection, and select the results of the query. `select` will maintain existing selection, and select the results of the query. `deselect` will maintain existing selection, and deselect the results of the query.  The operation behavior for this intersection query tool can also be changed by providing a custom implementation of the `VolumeIntersectionQueryController`, or by using the `setOperationTransform` method of the default controller.
     */
    operationType: VolumeIntersectionQueryType;
    /**
     * The viewer that this component is bound to. This is automatically assigned if added to the light-dom of a parent viewer element.
     */
    viewer?: HTMLVertexViewerElement;
  }
  interface VertexViewerButton {}
  interface VertexViewerDefaultToolbar {
    /**
     * The duration of animations, in milliseconds. Defaults to `1000`.
     */
    animationMs: number;
    /**
     * Indicates whether animations will be used when performing camera operations. Defaults to `true`.
     */
    animationsDisabled: boolean;
    /**
     * Specifies the direction that UI elements are placed.
     */
    direction: ViewerToolbarGroupDirection;
    /**
     * Specifies where the toolbar is positioned.
     */
    placement: ViewerToolbarPlacement;
    /**
     * An instance of the viewer that operations will be performed on. If contained within a `<vertex-viewer>` element, this property will automatically be wired.
     */
    viewer?: HTMLVertexViewerElement;
  }
  interface VertexViewerDomElement {
    /**
     * Disables the billboarding behavior of the element. When billboarding is enabled, the element will always be oriented towards the screen.
     */
    billboardOff: boolean;
    /**
     * Disables interaction events from children.
     */
    interactionsOff: boolean;
    /**
     * The local matrix of this element.
     */
    matrix: Matrix4.Matrix4;
    /**
     * Indicates if the element is hidden by geometry. This property can be used with a CSS selector to modify the appearance of the element when its occluded.
     * @example ```html <style>   vertex-viewer-dom-element[occluded] {     opacity: 0;   } </style> ```
     */
    occluded: boolean;
    /**
     * Disables occlusion testing for this element. Defaults to enabled. When enabled, the elements position will be tested against the current depth buffer. If the position is occluded, then the `occluded` attribute will be set.
     */
    occlusionOff: boolean;
    /**
     * The local 3D position of where this element is located.
     */
    position: Vector3.Vector3;
    /**
     * The local 3D position of where this element is located, as a JSON string. JSON representation can either be in the format of `[x, y, z]` or `{"x": 0, "y": 0, "z": 0}`.
     */
    positionJson: string;
    /**
     * The local rotation of this element.
     */
    quaternion: Quaternion.Quaternion;
    /**
     * The local quaternion rotation of this element, as a JSON string. JSON representation can either be `[x, y, z, w]` or `{"x": 0, "y": 0, "z": 0, "w": 1}`.
     */
    quaternionJson: string;
    /**
     * The local rotation of this element in Euler angles.
     */
    rotation?: Euler.Euler;
    /**
     * The local rotation of this element in Euler angles, as a JSON string. JSON representation can either be `[x, y, z, order]` or `{"x": 0, "y": 0, "z": 0, "order": "xyz"}`.
     */
    rotationJson?: string;
    /**
     * The local scale of this element.
     */
    scale: Vector3.Vector3;
    /**
     * The local scale of this element, as a JSON string. JSON string representation can either be in the format of `[x, y, z]` or `{"x": 0, "y": 0, "z": 0}`.
     */
    scaleJson: string;
  }
  interface VertexViewerDomGroup {
    /**
     * The local matrix of this element.
     */
    matrix: Matrix4.Matrix4;
    /**
     * The local 3D position of where this element is located.
     */
    position: Vector3.Vector3;
    /**
     * The local 3D position of where this element is located, as a JSON string. JSON representation can either be in the format of `[x, y, z]` or `{"x": 0, "y": 0, "z": 0}`.
     */
    positionJson: string;
    /**
     * The local rotation of this element.
     */
    quaternion: Quaternion.Quaternion;
    /**
     * The local rotation of this element, as a JSON string. JSON representation can either be `[x, y, z, w]` or `{"x": 0, "y": 0, "z": 0, "w": 1}`.
     */
    quaternionJson: string;
    /**
     * The local rotation of this element in Euler angles.
     */
    rotation?: Euler.Euler;
    /**
     * The local rotation of this element in Euler angles, as a JSON string. JSON representation can either be `[x, y, z, order]` or `{"x": 0, "y": 0, "z": 0, "order": "xyz"}`.
     */
    rotationJson?: string;
    /**
     * The local scale of this element.
     */
    scale: Vector3.Vector3;
    /**
     * The local scale of this element, as a JSON string. JSON string representation can either be in the format of `[x, y, z]` or `{"x": 0, "y": 0, "z": 0}`.
     */
    scaleJson: string;
  }
  interface VertexViewerDomRenderer {
    /**
     * The current camera of the frame.  This property will automatically be set when supplying a viewer to the component, or when added as a child to `<vertex-viewer>`.
     */
    camera?: FrameCameraBase;
    /**
     * The current depth buffer of the frame.  This property will automatically be set when supplying a viewer to the component, or when added as a child to `<vertex-viewer>`.
     */
    depthBuffer?: DepthBuffer;
    /**
     * Specifies the drawing mode for the renderer.  When in `3d` mode, elements are positioned using CSS 3D transforms and will scale and rotate with the camera. In `2d` mode, a simpler 2D transform is used, and elements will not scale or rotate with camera changes.
     */
    drawMode: ViewerDomRendererDrawMode;
    /**
     * The viewer synced to this renderer. This property will automatically be assigned if the renderer is a child of `<vertex-viewer>`.
     */
    viewer?: HTMLVertexViewerElement;
  }
  interface VertexViewerHitResultIndicator {
    /**
     * The normal of this indicator. This value will be represented as an arrow, and will be used alongside the provided `position` to display a plane.
     */
    normal?: Vector3.Vector3;
    /**
     * The position of this indicator. A point will be displayed at this position, and it will be used alongside the provided `normal` to display a plane and normal arrow centered at the position.
     */
    position?: Vector3.Vector3;
    /**
     * The viewer to connect to this indicator. If nested within a <vertex-viewer>, this property will be populated automatically.
     */
    viewer?: HTMLVertexViewerElement;
  }
  interface VertexViewerIcon {
    /**
     * The name of the icon to render.
     */
    name?: ViewerIconName;
    /**
     * The size of the icon. Can be `'sm' | 'md' | 'lg' | undefined`. Predefined sizes are set to:   * `sm`: 16px  * `md`: 24px  * `lg`: 32px  A custom size can be supplied by setting this field to `undefined` and setting `font-size` through CSS. Defaults to `md`.
     */
    size?: ViewerIconSize;
  }
  interface VertexViewerLayer {
    /**
     * Indicates if the layer should stretch to fill the size of its container's nearest positioned parent.
     */
    stretchOff: boolean;
  }
  interface VertexViewerMarkup {
    /**
     * Adds a new markup as a child to this component. A new markup component will be created from the template specified by `arrow-template-id`, `circle-template-id`, or if undefined a default element will be created.
     * @param markup The markup to add.
     * @returns The markup element that was created.
     * @see {@link ViewerMarkups.arrowTemplateId }
     * @see {@link ViewerMarkups.circleTemplateId }
     */
    addMarkup: (
      markup: Markup
    ) => Promise<
      | HTMLVertexViewerMarkupArrowElement
      | HTMLVertexViewerMarkupCircleElement
      | HTMLVertexViewerMarkupFreeformElement
    >;
    /**
     * An HTML template that describes the HTML to use for new arrow markup. It's expected that the template contains a `<vertex-viewer-markup-arrow>`.
     */
    arrowTemplateId?: string;
    /**
     * An HTML template that describes the HTML to use for new circle markup. It's expected that the template contains a `<vertex-viewer-markup-circle>`.
     */
    circleTemplateId?: string;
    /**
     * If `true`, disables adding or editing of markup through user interaction.
     */
    disabled: boolean;
    /**
     * An HTML template that describes the HTML to use for new freeform markup. It's expected that the template contains a `<vertex-viewer-markup-freeform>`.
     */
    freeformTemplateId?: string;
    /**
     * Returns the markup element associated to the given ID.
     * @param id The ID of the markup element to return.
     * @returns A markup element, or `undefined`.
     * @see {@link ViewerMarkup.getMarkupElements}
     */
    getMarkupElement: (
      id: string
    ) => Promise<
      | HTMLVertexViewerMarkupArrowElement
      | HTMLVertexViewerMarkupCircleElement
      | HTMLVertexViewerMarkupFreeformElement
      | undefined
    >;
    /**
     * Returns a list of markup elements that are children of this component.
     * @returns A list of all markups.
     * @see {@link ViewerMarkup.getMarkupElement}
     */
    getMarkupElements: () => Promise<
      Array<
        | HTMLVertexViewerMarkupArrowElement
        | HTMLVertexViewerMarkupCircleElement
        | HTMLVertexViewerMarkupFreeformElement
      >
    >;
    /**
     * Removes a markup with the given ID, and returns the HTML element associated to the markup. Returns `undefined` if no markup is found.
     * @param id The ID of the markup to remove.
     * @returns The markup element, or undefined.
     */
    removeMarkup: (
      id: string
    ) => Promise<
      | HTMLVertexViewerMarkupArrowElement
      | HTMLVertexViewerMarkupCircleElement
      | HTMLVertexViewerMarkupFreeformElement
      | undefined
    >;
    /**
     * Indicates if new markup should be automatically selected.
     */
    selectNew: boolean;
    /**
     * The ID of the markup that is selected.
     */
    selectedMarkupId?: string;
    /**
     * The type of markup to perform.
     */
    tool: ViewerMarkupToolType;
    /**
     * The viewer to connect to markup. If nested within a <vertex-viewer>, this property will be populated automatically.
     */
    viewer?: HTMLVertexViewerElement;
  }
  interface VertexViewerMarkupArrow {
    dispose: () => Promise<void>;
    /**
     * The position of the ending anchor. Can either be an instance of a `Point` or a JSON string representation in the format of `[x, y]` or `{"x": 0, "y": 0}`.  Points are expected to be relative coordinates from `[-0.5, 0.5]`, e.g. `[0, 0]` corresponds to a point in the center of the viewport.
     */
    end?: Point.Point;
    /**
     * The position of the ending anchor, as a JSON string. Can either be an instance of a `Point` or a JSON string representation in the format of `[x, y]` or `{"x": 0, "y": 0}`.  Points are expected to be relative coordinates from `[-0.5, 0.5]`, e.g. `[0, 0]` corresponds to a point in the center of the viewport.
     */
    endJson?: string;
    /**
     * A mode that specifies how the markup component should behave. When unset, the component will not respond to interactions with the handles. When `edit`, the markup anchors are interactive and the user is able to reposition them. When `create`, anytime the user clicks on the canvas, a new markup will be performed.
     */
    mode: ViewerMarkupArrowMode;
    /**
     * The position of the starting anchor. Can either be an instance of a `Point` or a JSON string representation in the format of `[x, y]` or `{"x": 0, "y": 0}`.  Points are expected to be relative coordinates from `[-0.5, 0.5]`, e.g. `[0, 0]` corresponds to a point in the center of the viewport.
     */
    start?: Point.Point;
    /**
     * The position of the starting anchor, as a JSON string. Can either be an instance of a `Point` or a JSON string representation in the format of `[x, y]` or `{"x": 0, "y": 0}`.  Points are expected to be relative coordinates from `[-0.5, 0.5]`, e.g. `[0, 0]` corresponds to a point in the center of the viewport.
     */
    startJson?: string;
    /**
     * The viewer to connect to markups.  This property will automatically be set when a child of a `<vertex-viewer-markup>` or `<vertex-viewer>` element.
     */
    viewer?: HTMLVertexViewerElement;
  }
  interface VertexViewerMarkupCircle {
    /**
     * The bounds of the circle. Can either be an instance of a `Rectangle` or a JSON string representation in the format of `[x, y, width, height]` or `{"x": 0, "y": 0, "width": 10, "height": 10}`.  Bounds are expected to have relative coordinates, with `[x, y]` from `[-0.5, 0.5]` and `[width, height]` from `[0, 1]`, e.g. `[0, 0, 0.25, 0.25]`corresponds to a circle with a diameter of one fourth the viewport's smallest size in the center of the viewport.
     */
    bounds?: Rectangle.Rectangle;
    /**
     * The bounds of the circle. Can either be an instance of a `Rectangle` or a JSON string representation in the format of `[x, y, width, height]` or `{"x": 0, "y": 0, "width": 0.1, "height": 0.1}`.  Bounds are expected to have relative coordinates, with `[x, y]` from `[-0.5, 0.5]` and `[width, height]` from `[0, 1]`, e.g. `[0, 0, 0.25, 0.25]`corresponds to a circle with a diameter of one fourth the viewport's smallest size in the center of the viewport.
     */
    boundsJson?: string;
    dispose: () => Promise<void>;
    /**
     * A mode that specifies how the markup component should behave. When unset, the component will not respond to interactions with the handles. When `edit`, the markup anchors are interactive and the user is able to reposition them. When `create`, anytime the user clicks on the canvas, a new markup will be performed.
     */
    mode: ViewerMarkupCircleMode;
    /**
     * The viewer to connect to markups.  This property will automatically be set when a child of a `<vertex-viewer-markup>` or `<vertex-viewer>` element.
     */
    viewer?: HTMLVertexViewerElement;
  }
  interface VertexViewerMarkupFreeform {
    /**
     * The bounds of the freeform. Can either be an instance of a `Rectangle` or a JSON string representation in the format of `[x, y, width, height]` or `{"x": 0, "y": 0, "width": 10, "height": 10}`.  Bounds are expected to have relative coordinates, with `[x, y]` from `[-0.5, 0.5]` and `[width, height]` from `[0, 1]`, e.g. `[0, 0, 0.25, 0.25]`corresponds to a freeform with a diameter of one fourth the viewport's smallest size in the center of the viewport.
     */
    bounds?: Rectangle.Rectangle;
    /**
     * The bounds of the freeform. Can either be an instance of a `Rectangle` or a JSON string representation in the format of `[x, y, width, height]` or `{"x": 0, "y": 0, "width": 0.1, "height": 0.1}`.  Bounds are expected to have relative coordinates, with `[x, y]` from `[-0.5, 0.5]` and `[width, height]` from `[0, 1]`, e.g. `[0, 0, 0.25, 0.25]`corresponds to a freeform with a diameter of one fourth the viewport's smallest size in the center of the viewport.
     */
    boundsJson?: string;
    dispose: () => Promise<void>;
    /**
     * A mode that specifies how the markup component should behave. When unset, the component will not respond to interactions with the handles. When `edit`, the markup anchors are interactive and the user is able to reposition them. When `create`, anytime the user clicks on the canvas, a new markup will be performed.
     */
    mode: ViewerMarkupFreeformMode;
    /**
     * The positions of the various points of this freeform markup. Can either be an array of `Point`s or a JSON string representation in the format of `[[x1, y1], [x2, y2]]` or `[{"x": 0, "y": 0}, {"x": 0, "y": 0}]`.  Points are expected to be relative coordinates from `[-0.5, 0.5]`, e.g. `[0, 0]` corresponds to a point in the center of the viewport.
     */
    points?: Point.Point[];
    /**
     * The positions of the various points of this freeform markup. Can either be an array of `Point`s or a JSON string representation in the format of `[[x1, y1], [x2, y2]]` or `[{"x": 0, "y": 0}, {"x": 0, "y": 0}]`.  Points are expected to be relative coordinates from `[-0.5, 0.5]`, e.g. `[0, 0]` corresponds to a point in the center of the viewport.
     */
    pointsJson?: string;
    /**
     * The viewer to connect to markups.  This property will automatically be set when a child of a `<vertex-viewer-markup>` or `<vertex-viewer>` element.
     */
    viewer?: HTMLVertexViewerElement;
  }
  interface VertexViewerMarkupTool {
    /**
     * An HTML template that describes the HTML to use for new arrow markup. It's expected that the template contains a `<vertex-viewer-markup-arrow>`.
     */
    arrowTemplateId?: string;
    /**
     * An HTML template that describes the HTML to use for new circle markup. It's expected that the template contains a `<vertex-viewer-markup-circle>`.
     */
    circleTemplateId?: string;
    /**
     * Disables markups.  This property will automatically be set when a child of a `<vertex-viewer-markup>` element.
     */
    disabled: boolean;
    /**
     * An HTML template that describes the HTML to use for new freeform markup. It's expected that the template contains a `<vertex-viewer-markup-freeform>`.
     */
    freeformTemplateId?: string;
    /**
     * Resets the state of the internally managed markup element to allow for creating a new markup. This state is automatically managed when this element is placed as a child of a `<vertex-viewer-markup>` element.
     */
    reset: () => Promise<void>;
    /**
     * The type of markup.  This property will automatically be set when a child of a `<vertex-viewer-markup>` element.
     */
    tool: ViewerMarkupToolType;
    /**
     * The viewer to connect to markup.  This property will automatically be set when a child of a `<vertex-viewer-markup>` or `<vertex-viewer>` element.
     */
    viewer?: HTMLVertexViewerElement;
  }
  interface VertexViewerMeasurementDetails {
    /**
     * An optional formatter that can be used to format the display of an angle. The formatting function is passed a calculated angle in degrees and is expected to return a string.
     */
    angleFormatter?: Formatter<number>;
    /**
     * The unit of angle-based measurement.
     */
    angleUnits: AngleUnitType;
    /**
     * An optional formatter that can be used to format the display of an area. The formatting function is passed a calculated area and is expected to return a string.
     */
    areaFormatter?: Formatter<number>;
    /**
     * An optional formatter that can be used to format the display of a distance. The formatting function is passed a calculated real-world distance and is expected to return a string.
     */
    distanceFormatter?: Formatter<number>;
    /**
     * The unit of distance-based measurement.
     */
    distanceUnits: DistanceUnitType;
    /**
     * The number of fraction digits to display.
     */
    fractionalDigits: number;
    /**
     * The `MeasurementModel` that should be reflected in these details. If not specified, a new `MeasurementModel` will be created, which can then be used to update the display.
     */
    measurementModel?: MeasurementModel;
    /**
     * The outcome to display. This property is automatically updated if a measurement model is provided.
     */
    measurementOutcome?: MeasurementOutcome;
    /**
     * The manager that the component will use to present measurement overlays.
     */
    measurementOverlays?: MeasurementOverlayManager;
    /**
     * A set of result types to display. If `undefined`, then all results will be displayed.
     */
    resultTypes?: MeasurementResult['type'][];
  }
  interface VertexViewerMeasurementDistance {
    /**
     * The distance from an anchor to its label.
     */
    anchorLabelOffset: number;
    /**
     * The camera used to position the anchors. If `viewer` is defined, then the projection view matrix of the viewer will be used.
     */
    camera?: FrameCameraBase1;
    /**
     * Computes the bounding boxes of the anchors and label. **Note:** invoking this function uses `getBoundingClientRect` internally and will cause a relayout of the DOM.
     */
    computeElementMetrics: () => Promise<
      ViewerMeasurementDistanceElementMetrics | undefined
    >;
    /**
     * The distance between `start` and `end` in real world units. Value will be undefined if the start and end positions are undefined, or if the measurement is invalid.
     */
    distance?: number;
    /**
     * The world position of the ending anchor.
     */
    end?: Vector3.Vector3;
    /**
     * The world position of the ending anchor, as a JSON string. The JSON string can be an array or object representation in the format of `[x, y, z]` or `{"x": 0, "y": 0, "z": 0}`.
     */
    endJson?: string;
    /**
     * The number of fraction digits to display.
     */
    fractionalDigits: number;
    hitProvider?: PointToPointHitProvider;
    indicatorPt?: Vector3.Vector3;
    /**
     * A property that reflects which anchor is currently being interacted with.
     */
    interactingAnchor: Anchor | 'none';
    /**
     * Indicates if the measurement is invalid. A measurement is invalid if either the start or end position are not on the surface of the model.
     */
    invalid: boolean;
    /**
     * An optional formatter that can be used to format the display of a distance. The formatting function is passed a calculated real-world distance and is expected to return a string.
     */
    labelFormatter?: Formatter<number | undefined>;
    /**
     * The length of the caps at each end of the distance measurement.
     */
    lineCapLength: number;
    /**
     * The measurement model that will be updated when this measurement changes. You can pass this to a <vertex-viewer-measurement-details> component to display measurement outcomes.
     */
    measurementModel: MeasurementModel;
    /**
     * A mode that specifies how the measurement component should behave.  When unset, the component will not respond to interactions with the handles.  When `edit`, the measurement anchors are interactive and the user is able to reposition them.  When `replace`, anytime the user clicks on the canvas, a new measurement will be created and replace any existing measurement. After a measurement is created, the measurement will be editable.
     */
    mode: ViewerMeasurementDistanceMode;
    /**
     * Enables the display of axis reference lines between the start and end point.
     */
    showAxisReferenceLines: boolean;
    /**
     * The distance, in pixels, between the mouse and nearest snappable edge. A value of 0 disables snapping.
     */
    snapDistance: number;
    /**
     * The world position of the starting anchor.
     */
    start?: Vector3.Vector3;
    /**
     * The world position of the starting anchor, as a JSON string. The JSON string can be an array or object representation in the format of `[x, y, z]` or `{"x": 0, "y": 0, "z": 0}`.
     */
    startJson?: string;
    /**
     * The unit of measurement.
     */
    units: DistanceUnitType;
    /**
     * The viewer to connect to this measurement. The measurement will redraw any time the viewer redraws the scene.
     */
    viewer?: HTMLVertexViewerElement;
  }
  interface VertexViewerMeasurementLine {
    /**
     * A length of the line cap. The line cap is a line at each end of a line.
     */
    capLength: number;
    /**
     * A point that specifies the ending point of the line.
     */
    end: Point.Point;
    /**
     * The type of [SVG pointer events](https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/pointer-events) that the line should respond to.
     */
    pointerEvents: string;
    /**
     * A point that specifies the starting point of the line.
     */
    start: Point.Point;
  }
  interface VertexViewerMeasurementOverlays {
    camera?: FrameCameraBase1;
    /**
     * The model that contains the overlays to present.
     */
    measurementOverlays: MeasurementOverlayManager;
    /**
     * The viewer that this component is bound to.
     */
    viewer?: HTMLVertexViewerElement;
  }
  interface VertexViewerMeasurementPrecise {
    /**
     * An optional configuration to setup network configuration of measurement endpoints.
     */
    config?: PartialConfig | string;
    /**
     * The environment that will be used to request measurement results.
     */
    configEnv: Environment;
    measurableEntityTypes: EntityType[];
    /**
     * The controller that is responsible for performing measurements and updating the model.
     */
    measurementController?: MeasurementController;
    /**
     * The model that contains the entities and outcomes from performing precise measurements.
     */
    measurementModel: MeasurementModel;
    /**
     * The manager that is responsible for measurement overlays to present by this component.
     */
    measurementOverlays: MeasurementOverlayManager;
    /**
     * The viewer that this component is bound to. This is automatically assigned if added to the light-dom of a parent viewer element.
     */
    viewer?: HTMLVertexViewerElement;
  }
  interface VertexViewerPinGroup {
    /**
     * The dimensions of the canvas for the pins
     */
    elementBounds?: DOMRect;
    /**
     * The local matrix of this element.
     */
    matrix: Matrix4.Matrix4;
    /**
     * The pin to draw for the group
     */
    pin?: Pin;
    /**
     * The controller that drives behavior for pin operations
     */
    pinController?: PinController;
    /**
     * The model that contains the entities and outcomes from performing pin operations
     */
    pinModel: PinModel;
    /**
     * Projection view matrix used for computing the position of the pin line
     */
    projectionViewMatrix: Matrix4.Matrix4;
    /**
     * Whether or not the pin is "selected"
     */
    selected: boolean;
  }
  interface VertexViewerPinLabel {
    /**
     * The dimensions of the canvas for the pins
     */
    elementBounds?: DOMRect;
    /**
     * The pin to draw for the group
     */
    pin?: TextPin;
    /**
     * The controller that drives behavior for pin operations
     */
    pinController?: PinController;
    /**
     * Gives focus to the the component's internal text input.
     */
    setFocus: () => Promise<void>;
    /**
     * The current text value of the component. Value is updated on user interaction.
     */
    value: string;
  }
  interface VertexViewerPinLabelLine {
    labelPoint: Point.Point | undefined;
    pin: Pin | undefined;
    pinPoint: Point.Point | undefined;
  }
  interface VertexViewerPinTool {
    /**
     * The accent color for new pins. Setting this will override the accent template color, and will be used for any new pins created with this `vertex-viewer-pin-tool`. This styling applies to some background colors, etc
     */
    accentColor: Color.Color | string | undefined;
    /**
     * The mode of the pin tool
     */
    mode: ViewerPinToolMode;
    /**
     * The controller that is responsible for drawing pins and updating the model
     */
    pinController?: PinController;
    /**
     * The model that contains the entities and outcomes from performing pin annotations
     */
    pinModel: PinModel;
    /**
     * The primary color for new pins. Setting this will override the primary template color, and will be used for any new pins created with this `vertex-viewer-pin-tool`. This styling applies to pin anchors, and borders, etc.
     */
    primaryColor: Color.Color | string | undefined;
    /**
     * The type of pin.  This property will automatically be set.
     */
    tool: ViewerPinToolType;
    /**
     * The viewer that this component is bound to. This is automatically assigned if added to the light-dom of a parent viewer element.
     */
    viewer?: HTMLVertexViewerElement;
  }
  interface VertexViewerSpinner {
    /**
     * The size of the spinner. Can be `'xs' | 'sm' | 'md' | 'lg' | undefined`. Predefined sizes are set to:   * `xm`: 16px  * `sm`: 24px  * `md`: 32px  * `lg`: 64px
     */
    size?: SpinnerSize;
  }
  interface VertexViewerTeleportTool {
    /**
     * The duration of animations, in milliseconds. Defaults to `500`.
     */
    animationMs?: number;
    /**
     * Indicates whether animations will be used when performing camera operations. Defaults to `false`.
     */
    animationsDisabled: boolean;
    controller?: WalkModeController;
    /**
     * The type of teleportation to perform when clicking.  `teleport` - the camera's `position` is moved to the location of the hit result constrained by the plane represented by the camera's current `position` and `up` vectors.  `teleport-and-align` - the camera's `position`, `lookAt`, and `up` vectors are updated to align to the plane represented by the hit result's position and normal.  `teleport-toward` - the camera's `position` is moved a fixed distance toward the location of the hit result constrained by the plane represented by the camera's current `position` and `up` vectors.  `undefined` - no teleportation will occur when clicking.  Defaults to `undefined`.
     */
    mode?: ViewerTeleportMode;
    model: WalkModeModel;
    /**
     * The viewer that this component is bound to. This is automatically assigned if added to the light-dom of a parent viewer element.
     */
    viewer?: HTMLVertexViewerElement;
  }
  interface VertexViewerToolbar {
    direction: ViewerToolbarDirection;
    /**
     * Specifies where the toolbar is positioned.
     */
    placement: ViewerToolbarPlacement;
  }
  interface VertexViewerToolbarGroup {
    direction: ViewerToolbarGroupDirection;
  }
  interface VertexViewerTransformWidget {
    /**
     * The controller that is responsible for performing transforms.
     */
    controller?: TransformController;
    /**
     * @ignore Visible for testing.
     */
    hovered?: Drawable;
    /**
     * The starting position of this transform widget. This position will be updated as transforms occur. Setting this value to `undefined` will remove the widget.
     */
    position?: Vector3.Vector3;
    /**
     * The starting angle for the transform widget. This rotation will be updated as the rotations occur.
     */
    rotation?: Euler.Euler;
    /**
     * The viewer to connect to transforms. If nested within a <vertex-viewer>, this property will be populated automatically.
     */
    viewer?: HTMLVertexViewerElement;
    /**
     * Determines whether or not the x-rotation is disabled on the widget
     */
    xRotationDisabled: boolean;
    /**
     * Determines whether or not the x-translation is disabled on the widget
     */
    xTranslationDisabled: boolean;
    /**
     * Determines whether or not the y-rotation is disabled on the widget
     */
    yRotationDisabled: boolean;
    /**
     * Determines whether or not the y-translation is disabled on the widget
     */
    yTranslationDisabled: boolean;
    /**
     * Determines whether or not the z-rotation is disabled on the widget
     */
    zRotationDisabled: boolean;
    /**
     * Determines whether or not the z-translation is disabled on the widget
     */
    zTranslationDisabled: boolean;
  }
  interface VertexViewerViewCube {
    /**
     * The duration of the animation, in milliseconds, when a user performs a standard view interaction. Set to 0 to disable animations.
     */
    animationDuration: number;
    camera?: FramePerspectiveCamera;
    /**
     * Disables interactions for standard views.
     */
    standardViewsOff: boolean;
    /**
     * Disables the display of the triad.
     */
    triadOff: boolean;
    /**
     * The viewer element that is connected to the view cube.
     */
    viewer?: HTMLVertexViewerElement;
    worldOrientation: Orientation;
    /**
     * The label for the side of the cube on the negative x-axis.
     */
    xNegativeLabel: string;
    /**
     * The label for the side of the cube on the positive x-axis.
     */
    xPositiveLabel: string;
    /**
     * The label for the side of the cube on the negative y-axis.
     */
    yNegativeLabel: string;
    /**
     * The label for the side of the cube on the positive y-axis.
     */
    yPositiveLabel: string;
    /**
     * The label for the side of the cube on the negative z-axis.
     */
    zNegativeLabel: string;
    /**
     * The label for the side of the cube on the positive z-axis.
     */
    zPositiveLabel: string;
  }
  interface VertexViewerWalkModeTool {
    /**
     * The `WalkModeController` responsible for controlling `KeyBinding`s and excluded elements, as well as updating the `WalkModeModel` with various configuration settings.
     */
    controller?: WalkModeController;
    /**
     * Determines whether the interaction handlers for this tool should respond to events. When set to `true`, the default viewer interaction mode will be overridden to use the `pivot` camera interaction type, keyboard controls for movement will be added, and setting the `teleportMode` will enable the tool.  Defaults to `true`.
     */
    enabled: boolean;
    /**
     * The `WalkModeModel` responsible for tracking configuration and emitting events for interaction handlers to respond to.
     */
    model: WalkModeModel;
    /**
     * The type of teleportation to perform when clicking. This value is passed through to a `<vertex-viewer-teleport-tool>`'s mode attribute.  `teleport` - the camera's `position` is moved to the location of the hit result constrained by the plane represented by the camera's current `position` and `up` vectors.  `teleport-and-align` - the camera's `position`, `lookAt`, and `up` vectors are updated to align to the plane represented by the hit result's position and normal.  `teleport-toward` - the camera's `position` is moved a fixed distance toward the location of the hit result constrained by the plane represented by the camera's current `position` and `up` vectors.  `undefined` - no teleportation will occur when clicking.  Defaults to `undefined`.
     */
    teleportMode?: ViewerTeleportMode;
    /**
     * The viewer that this component is bound to. This is automatically assigned if added to the light-dom of a parent viewer element.
     */
    viewer?: HTMLVertexViewerElement;
  }
}
export interface VertexSceneTreeCustomEvent<T> extends CustomEvent<T> {
  detail: T;
  target: HTMLVertexSceneTreeElement;
}
export interface VertexSceneTreeSearchCustomEvent<T> extends CustomEvent<T> {
  detail: T;
  target: HTMLVertexSceneTreeSearchElement;
}
export interface VertexSceneTreeTableCellCustomEvent<T> extends CustomEvent<T> {
  detail: T;
  target: HTMLVertexSceneTreeTableCellElement;
}
export interface VertexSceneTreeTableLayoutCustomEvent<T>
  extends CustomEvent<T> {
  detail: T;
  target: HTMLVertexSceneTreeTableLayoutElement;
}
export interface VertexViewerCustomEvent<T> extends CustomEvent<T> {
  detail: T;
  target: HTMLVertexViewerElement;
}
export interface VertexViewerDomElementCustomEvent<T> extends CustomEvent<T> {
  detail: T;
  target: HTMLVertexViewerDomElementElement;
}
export interface VertexViewerDomGroupCustomEvent<T> extends CustomEvent<T> {
  detail: T;
  target: HTMLVertexViewerDomGroupElement;
}
export interface VertexViewerMarkupCustomEvent<T> extends CustomEvent<T> {
  detail: T;
  target: HTMLVertexViewerMarkupElement;
}
export interface VertexViewerMarkupArrowCustomEvent<T> extends CustomEvent<T> {
  detail: T;
  target: HTMLVertexViewerMarkupArrowElement;
}
export interface VertexViewerMarkupCircleCustomEvent<T> extends CustomEvent<T> {
  detail: T;
  target: HTMLVertexViewerMarkupCircleElement;
}
export interface VertexViewerMarkupFreeformCustomEvent<T>
  extends CustomEvent<T> {
  detail: T;
  target: HTMLVertexViewerMarkupFreeformElement;
}
export interface VertexViewerMarkupToolCustomEvent<T> extends CustomEvent<T> {
  detail: T;
  target: HTMLVertexViewerMarkupToolElement;
}
export interface VertexViewerMeasurementDistanceCustomEvent<T>
  extends CustomEvent<T> {
  detail: T;
  target: HTMLVertexViewerMeasurementDistanceElement;
}
export interface VertexViewerPinLabelCustomEvent<T> extends CustomEvent<T> {
  detail: T;
  target: HTMLVertexViewerPinLabelElement;
}
export interface VertexViewerTeleportToolCustomEvent<T> extends CustomEvent<T> {
  detail: T;
  target: HTMLVertexViewerTeleportToolElement;
}
export interface VertexViewerTransformWidgetCustomEvent<T>
  extends CustomEvent<T> {
  detail: T;
  target: HTMLVertexViewerTransformWidgetElement;
}
export interface VertexViewerWalkModeToolCustomEvent<T> extends CustomEvent<T> {
  detail: T;
  target: HTMLVertexViewerWalkModeToolElement;
}
declare global {
  interface HTMLVertexSceneTreeElement
    extends Components.VertexSceneTree,
      HTMLStencilElement {}
  var HTMLVertexSceneTreeElement: {
    prototype: HTMLVertexSceneTreeElement;
    new (): HTMLVertexSceneTreeElement;
  };
  interface HTMLVertexSceneTreeSearchElement
    extends Components.VertexSceneTreeSearch,
      HTMLStencilElement {}
  var HTMLVertexSceneTreeSearchElement: {
    prototype: HTMLVertexSceneTreeSearchElement;
    new (): HTMLVertexSceneTreeSearchElement;
  };
  interface HTMLVertexSceneTreeTableCellElement
    extends Components.VertexSceneTreeTableCell,
      HTMLStencilElement {}
  var HTMLVertexSceneTreeTableCellElement: {
    prototype: HTMLVertexSceneTreeTableCellElement;
    new (): HTMLVertexSceneTreeTableCellElement;
  };
  interface HTMLVertexSceneTreeTableColumnElement
    extends Components.VertexSceneTreeTableColumn,
      HTMLStencilElement {}
  var HTMLVertexSceneTreeTableColumnElement: {
    prototype: HTMLVertexSceneTreeTableColumnElement;
    new (): HTMLVertexSceneTreeTableColumnElement;
  };
  interface HTMLVertexSceneTreeTableHeaderElement
    extends Components.VertexSceneTreeTableHeader,
      HTMLStencilElement {}
  var HTMLVertexSceneTreeTableHeaderElement: {
    prototype: HTMLVertexSceneTreeTableHeaderElement;
    new (): HTMLVertexSceneTreeTableHeaderElement;
  };
  interface HTMLVertexSceneTreeTableLayoutElement
    extends Components.VertexSceneTreeTableLayout,
      HTMLStencilElement {}
  var HTMLVertexSceneTreeTableLayoutElement: {
    prototype: HTMLVertexSceneTreeTableLayoutElement;
    new (): HTMLVertexSceneTreeTableLayoutElement;
  };
  interface HTMLVertexSceneTreeTableResizeDividerElement
    extends Components.VertexSceneTreeTableResizeDivider,
      HTMLStencilElement {}
  var HTMLVertexSceneTreeTableResizeDividerElement: {
    prototype: HTMLVertexSceneTreeTableResizeDividerElement;
    new (): HTMLVertexSceneTreeTableResizeDividerElement;
  };
  interface HTMLVertexSceneTreeToolbarElement
    extends Components.VertexSceneTreeToolbar,
      HTMLStencilElement {}
  var HTMLVertexSceneTreeToolbarElement: {
    prototype: HTMLVertexSceneTreeToolbarElement;
    new (): HTMLVertexSceneTreeToolbarElement;
  };
  interface HTMLVertexSceneTreeToolbarGroupElement
    extends Components.VertexSceneTreeToolbarGroup,
      HTMLStencilElement {}
  var HTMLVertexSceneTreeToolbarGroupElement: {
    prototype: HTMLVertexSceneTreeToolbarGroupElement;
    new (): HTMLVertexSceneTreeToolbarGroupElement;
  };
  interface HTMLVertexViewerElement
    extends Components.VertexViewer,
      HTMLStencilElement {}
  var HTMLVertexViewerElement: {
    prototype: HTMLVertexViewerElement;
    new (): HTMLVertexViewerElement;
  };
  interface HTMLVertexViewerBoxQueryToolElement
    extends Components.VertexViewerBoxQueryTool,
      HTMLStencilElement {}
  var HTMLVertexViewerBoxQueryToolElement: {
    prototype: HTMLVertexViewerBoxQueryToolElement;
    new (): HTMLVertexViewerBoxQueryToolElement;
  };
  interface HTMLVertexViewerButtonElement
    extends Components.VertexViewerButton,
      HTMLStencilElement {}
  var HTMLVertexViewerButtonElement: {
    prototype: HTMLVertexViewerButtonElement;
    new (): HTMLVertexViewerButtonElement;
  };
  interface HTMLVertexViewerDefaultToolbarElement
    extends Components.VertexViewerDefaultToolbar,
      HTMLStencilElement {}
  var HTMLVertexViewerDefaultToolbarElement: {
    prototype: HTMLVertexViewerDefaultToolbarElement;
    new (): HTMLVertexViewerDefaultToolbarElement;
  };
  interface HTMLVertexViewerDomElementElement
    extends Components.VertexViewerDomElement,
      HTMLStencilElement {}
  var HTMLVertexViewerDomElementElement: {
    prototype: HTMLVertexViewerDomElementElement;
    new (): HTMLVertexViewerDomElementElement;
  };
  interface HTMLVertexViewerDomGroupElement
    extends Components.VertexViewerDomGroup,
      HTMLStencilElement {}
  var HTMLVertexViewerDomGroupElement: {
    prototype: HTMLVertexViewerDomGroupElement;
    new (): HTMLVertexViewerDomGroupElement;
  };
  interface HTMLVertexViewerDomRendererElement
    extends Components.VertexViewerDomRenderer,
      HTMLStencilElement {}
  var HTMLVertexViewerDomRendererElement: {
    prototype: HTMLVertexViewerDomRendererElement;
    new (): HTMLVertexViewerDomRendererElement;
  };
  interface HTMLVertexViewerHitResultIndicatorElement
    extends Components.VertexViewerHitResultIndicator,
      HTMLStencilElement {}
  var HTMLVertexViewerHitResultIndicatorElement: {
    prototype: HTMLVertexViewerHitResultIndicatorElement;
    new (): HTMLVertexViewerHitResultIndicatorElement;
  };
  interface HTMLVertexViewerIconElement
    extends Components.VertexViewerIcon,
      HTMLStencilElement {}
  var HTMLVertexViewerIconElement: {
    prototype: HTMLVertexViewerIconElement;
    new (): HTMLVertexViewerIconElement;
  };
  interface HTMLVertexViewerLayerElement
    extends Components.VertexViewerLayer,
      HTMLStencilElement {}
  var HTMLVertexViewerLayerElement: {
    prototype: HTMLVertexViewerLayerElement;
    new (): HTMLVertexViewerLayerElement;
  };
  interface HTMLVertexViewerMarkupElement
    extends Components.VertexViewerMarkup,
      HTMLStencilElement {}
  var HTMLVertexViewerMarkupElement: {
    prototype: HTMLVertexViewerMarkupElement;
    new (): HTMLVertexViewerMarkupElement;
  };
  interface HTMLVertexViewerMarkupArrowElement
    extends Components.VertexViewerMarkupArrow,
      HTMLStencilElement {}
  var HTMLVertexViewerMarkupArrowElement: {
    prototype: HTMLVertexViewerMarkupArrowElement;
    new (): HTMLVertexViewerMarkupArrowElement;
  };
  interface HTMLVertexViewerMarkupCircleElement
    extends Components.VertexViewerMarkupCircle,
      HTMLStencilElement {}
  var HTMLVertexViewerMarkupCircleElement: {
    prototype: HTMLVertexViewerMarkupCircleElement;
    new (): HTMLVertexViewerMarkupCircleElement;
  };
  interface HTMLVertexViewerMarkupFreeformElement
    extends Components.VertexViewerMarkupFreeform,
      HTMLStencilElement {}
  var HTMLVertexViewerMarkupFreeformElement: {
    prototype: HTMLVertexViewerMarkupFreeformElement;
    new (): HTMLVertexViewerMarkupFreeformElement;
  };
  interface HTMLVertexViewerMarkupToolElement
    extends Components.VertexViewerMarkupTool,
      HTMLStencilElement {}
  var HTMLVertexViewerMarkupToolElement: {
    prototype: HTMLVertexViewerMarkupToolElement;
    new (): HTMLVertexViewerMarkupToolElement;
  };
  interface HTMLVertexViewerMeasurementDetailsElement
    extends Components.VertexViewerMeasurementDetails,
      HTMLStencilElement {}
  var HTMLVertexViewerMeasurementDetailsElement: {
    prototype: HTMLVertexViewerMeasurementDetailsElement;
    new (): HTMLVertexViewerMeasurementDetailsElement;
  };
  interface HTMLVertexViewerMeasurementDistanceElement
    extends Components.VertexViewerMeasurementDistance,
      HTMLStencilElement {}
  var HTMLVertexViewerMeasurementDistanceElement: {
    prototype: HTMLVertexViewerMeasurementDistanceElement;
    new (): HTMLVertexViewerMeasurementDistanceElement;
  };
  interface HTMLVertexViewerMeasurementLineElement
    extends Components.VertexViewerMeasurementLine,
      HTMLStencilElement {}
  var HTMLVertexViewerMeasurementLineElement: {
    prototype: HTMLVertexViewerMeasurementLineElement;
    new (): HTMLVertexViewerMeasurementLineElement;
  };
  interface HTMLVertexViewerMeasurementOverlaysElement
    extends Components.VertexViewerMeasurementOverlays,
      HTMLStencilElement {}
  var HTMLVertexViewerMeasurementOverlaysElement: {
    prototype: HTMLVertexViewerMeasurementOverlaysElement;
    new (): HTMLVertexViewerMeasurementOverlaysElement;
  };
  interface HTMLVertexViewerMeasurementPreciseElement
    extends Components.VertexViewerMeasurementPrecise,
      HTMLStencilElement {}
  var HTMLVertexViewerMeasurementPreciseElement: {
    prototype: HTMLVertexViewerMeasurementPreciseElement;
    new (): HTMLVertexViewerMeasurementPreciseElement;
  };
  interface HTMLVertexViewerPinGroupElement
    extends Components.VertexViewerPinGroup,
      HTMLStencilElement {}
  var HTMLVertexViewerPinGroupElement: {
    prototype: HTMLVertexViewerPinGroupElement;
    new (): HTMLVertexViewerPinGroupElement;
  };
  interface HTMLVertexViewerPinLabelElement
    extends Components.VertexViewerPinLabel,
      HTMLStencilElement {}
  var HTMLVertexViewerPinLabelElement: {
    prototype: HTMLVertexViewerPinLabelElement;
    new (): HTMLVertexViewerPinLabelElement;
  };
  interface HTMLVertexViewerPinLabelLineElement
    extends Components.VertexViewerPinLabelLine,
      HTMLStencilElement {}
  var HTMLVertexViewerPinLabelLineElement: {
    prototype: HTMLVertexViewerPinLabelLineElement;
    new (): HTMLVertexViewerPinLabelLineElement;
  };
  interface HTMLVertexViewerPinToolElement
    extends Components.VertexViewerPinTool,
      HTMLStencilElement {}
  var HTMLVertexViewerPinToolElement: {
    prototype: HTMLVertexViewerPinToolElement;
    new (): HTMLVertexViewerPinToolElement;
  };
  interface HTMLVertexViewerSpinnerElement
    extends Components.VertexViewerSpinner,
      HTMLStencilElement {}
  var HTMLVertexViewerSpinnerElement: {
    prototype: HTMLVertexViewerSpinnerElement;
    new (): HTMLVertexViewerSpinnerElement;
  };
  interface HTMLVertexViewerTeleportToolElement
    extends Components.VertexViewerTeleportTool,
      HTMLStencilElement {}
  var HTMLVertexViewerTeleportToolElement: {
    prototype: HTMLVertexViewerTeleportToolElement;
    new (): HTMLVertexViewerTeleportToolElement;
  };
  interface HTMLVertexViewerToolbarElement
    extends Components.VertexViewerToolbar,
      HTMLStencilElement {}
  var HTMLVertexViewerToolbarElement: {
    prototype: HTMLVertexViewerToolbarElement;
    new (): HTMLVertexViewerToolbarElement;
  };
  interface HTMLVertexViewerToolbarGroupElement
    extends Components.VertexViewerToolbarGroup,
      HTMLStencilElement {}
  var HTMLVertexViewerToolbarGroupElement: {
    prototype: HTMLVertexViewerToolbarGroupElement;
    new (): HTMLVertexViewerToolbarGroupElement;
  };
  interface HTMLVertexViewerTransformWidgetElement
    extends Components.VertexViewerTransformWidget,
      HTMLStencilElement {}
  var HTMLVertexViewerTransformWidgetElement: {
    prototype: HTMLVertexViewerTransformWidgetElement;
    new (): HTMLVertexViewerTransformWidgetElement;
  };
  interface HTMLVertexViewerViewCubeElement
    extends Components.VertexViewerViewCube,
      HTMLStencilElement {}
  var HTMLVertexViewerViewCubeElement: {
    prototype: HTMLVertexViewerViewCubeElement;
    new (): HTMLVertexViewerViewCubeElement;
  };
  interface HTMLVertexViewerWalkModeToolElement
    extends Components.VertexViewerWalkModeTool,
      HTMLStencilElement {}
  var HTMLVertexViewerWalkModeToolElement: {
    prototype: HTMLVertexViewerWalkModeToolElement;
    new (): HTMLVertexViewerWalkModeToolElement;
  };
  interface HTMLElementTagNameMap {
    'vertex-scene-tree': HTMLVertexSceneTreeElement;
    'vertex-scene-tree-search': HTMLVertexSceneTreeSearchElement;
    'vertex-scene-tree-table-cell': HTMLVertexSceneTreeTableCellElement;
    'vertex-scene-tree-table-column': HTMLVertexSceneTreeTableColumnElement;
    'vertex-scene-tree-table-header': HTMLVertexSceneTreeTableHeaderElement;
    'vertex-scene-tree-table-layout': HTMLVertexSceneTreeTableLayoutElement;
    'vertex-scene-tree-table-resize-divider': HTMLVertexSceneTreeTableResizeDividerElement;
    'vertex-scene-tree-toolbar': HTMLVertexSceneTreeToolbarElement;
    'vertex-scene-tree-toolbar-group': HTMLVertexSceneTreeToolbarGroupElement;
    'vertex-viewer': HTMLVertexViewerElement;
    'vertex-viewer-box-query-tool': HTMLVertexViewerBoxQueryToolElement;
    'vertex-viewer-button': HTMLVertexViewerButtonElement;
    'vertex-viewer-default-toolbar': HTMLVertexViewerDefaultToolbarElement;
    'vertex-viewer-dom-element': HTMLVertexViewerDomElementElement;
    'vertex-viewer-dom-group': HTMLVertexViewerDomGroupElement;
    'vertex-viewer-dom-renderer': HTMLVertexViewerDomRendererElement;
    'vertex-viewer-hit-result-indicator': HTMLVertexViewerHitResultIndicatorElement;
    'vertex-viewer-icon': HTMLVertexViewerIconElement;
    'vertex-viewer-layer': HTMLVertexViewerLayerElement;
    'vertex-viewer-markup': HTMLVertexViewerMarkupElement;
    'vertex-viewer-markup-arrow': HTMLVertexViewerMarkupArrowElement;
    'vertex-viewer-markup-circle': HTMLVertexViewerMarkupCircleElement;
    'vertex-viewer-markup-freeform': HTMLVertexViewerMarkupFreeformElement;
    'vertex-viewer-markup-tool': HTMLVertexViewerMarkupToolElement;
    'vertex-viewer-measurement-details': HTMLVertexViewerMeasurementDetailsElement;
    'vertex-viewer-measurement-distance': HTMLVertexViewerMeasurementDistanceElement;
    'vertex-viewer-measurement-line': HTMLVertexViewerMeasurementLineElement;
    'vertex-viewer-measurement-overlays': HTMLVertexViewerMeasurementOverlaysElement;
    'vertex-viewer-measurement-precise': HTMLVertexViewerMeasurementPreciseElement;
    'vertex-viewer-pin-group': HTMLVertexViewerPinGroupElement;
    'vertex-viewer-pin-label': HTMLVertexViewerPinLabelElement;
    'vertex-viewer-pin-label-line': HTMLVertexViewerPinLabelLineElement;
    'vertex-viewer-pin-tool': HTMLVertexViewerPinToolElement;
    'vertex-viewer-spinner': HTMLVertexViewerSpinnerElement;
    'vertex-viewer-teleport-tool': HTMLVertexViewerTeleportToolElement;
    'vertex-viewer-toolbar': HTMLVertexViewerToolbarElement;
    'vertex-viewer-toolbar-group': HTMLVertexViewerToolbarGroupElement;
    'vertex-viewer-transform-widget': HTMLVertexViewerTransformWidgetElement;
    'vertex-viewer-view-cube': HTMLVertexViewerViewCubeElement;
    'vertex-viewer-walk-mode-tool': HTMLVertexViewerWalkModeToolElement;
  }
}
declare namespace LocalJSX {
  interface VertexSceneTree {
    /**
     * An object to configure the scene tree.
     */
    config?: PartialConfig | string;
    /**
     * Sets the default environment for the viewer. This setting is used for auto-configuring network hosts.  Use the `config` property for manually setting hosts.
     */
    configEnv?: Environment;
    controller?: SceneTreeController;
    /**
     * A list of part metadata keys that will be made available to each row. This metadata can be used for data binding inside the scene tree's template.
     */
    metadataKeys?: MetadataKey[];
    /**
     * Indicates whether the metadata search should use an exact match.
     */
    metadataSearchExactMatch?: boolean;
    /**
     * A list of the metadata keys that a scene tree search should be performed on.
     */
    metadataSearchKeys?: MetadataKey[];
    /**
     * An event that is emitted when this <vertex-scene-tree> encounters a connection error.
     */
    onConnectionError?: (
      event: VertexSceneTreeCustomEvent<SceneTreeErrorDetails>
    ) => void;
    /**
     * An event that is emitted when the first row of this <vertex-scene-tree> has been rendered.
     */
    onFirstRowRendered?: (event: VertexSceneTreeCustomEvent<void>) => void;
    /**
     * The number of offscreen rows above and below the viewport to render. Having a higher number reduces the chance of the browser not displaying a row while scrolling.
     */
    overScanCount?: number;
    /**
     * A callback that is invoked immediately before a row is about to rendered. This callback can return additional data that can be bound to in a template.
     * @example ```html <script>   const table = document.querySelector('vertex-scene-tree-table');   table.rowData = (row) => {     return { func: () => console.log('row', row.node.name) };   } </script>  <vertex-scene-tree>  <vertex-scene-tree-table>    <vertex-scene-tree-table-column>      <template>        <button event:click="{{row.data.func}}">Hi</button>      </template>    </vertex-scene-tree-table-column>  </vertex-scene-tree-table> </vertex-scene-tree> ```
     */
    rowData?: RowDataProvider;
    /**
     * An instance of a `<vertex-viewer>` element. Either this property or `viewerSelector` must be set.
     */
    viewer?: HTMLVertexViewerElement | null;
    /**
     * A CSS selector that points to a `<vertex-viewer>` element. Either this property or `viewer` must be set.
     */
    viewerSelector?: string;
  }
  interface VertexSceneTreeSearch {
    /**
     * The scene tree controller
     */
    controller?: SceneTreeController;
    /**
     * Specifies the delay, in milliseconds, to emit `search` events after user input.
     */
    debounce?: number;
    /**
     * If `true`, disables user interaction of the component.
     */
    disabled?: boolean;
    /**
     * An event that is emitted when a user has inputted or cleared the search term. The event may be delayed according to the current `debounce` value.
     */
    onSearch?: (event: VertexSceneTreeSearchCustomEvent<string>) => void;
    /**
     * Placeholder text if `value` is empty.
     */
    placeholder?: string;
    /**
     * The current text value of the component. Value is updated on user interaction.
     */
    value?: string;
  }
  interface VertexSceneTreeTableCell {
    /**
     * Indicates whether to display a button for toggling the expanded state of the node associated with this cell.
     */
    expandToggle?: boolean;
    /**
     * An optional handler that will override this cell's default expansion behavior. The registered handler will receive the `pointerup` event, the node data for the row this cell is associated with, and a reference to the parent `<vertex-scene-tree>` element for performing operations.
     */
    expansionHandler?: SceneTreeOperationHandler;
    hoverController?: SceneTreeCellHoverController;
    hovered?: boolean;
    isScrolling?: boolean;
    /**
     * The node data that is associated to the row that this cell belongs to. Contains information related to if the node is expanded, visible, etc.
     */
    node?: Node.AsObject;
    /**
     * Used for internals or testing.
     * @private
     */
    onCellLoaded?: (event: VertexSceneTreeTableCellCustomEvent<void>) => void;
    /**
     * An event that is emitted when a user requests to expand the node. This is emitted even if interactions are disabled.
     */
    onExpandToggled?: (
      event: VertexSceneTreeTableCellCustomEvent<SceneTreeTableCellEventDetails>
    ) => void;
    /**
     * An event that is emitted when a user requests to change the node's selection state. This event is emitted even if interactions are disabled.
     */
    onSelectionToggled?: (
      event: VertexSceneTreeTableCellCustomEvent<SceneTreeTableCellEventDetails>
    ) => void;
    /**
     * An event that is emitted when a user requests to change the node's visibility. This event is emitted even if interactions are disabled.
     */
    onVisibilityToggled?: (
      event: VertexSceneTreeTableCellCustomEvent<SceneTreeTableCellEventDetails>
    ) => void;
    /**
     * The value to display in this cell if the `value` specified is undefined. Defaults to "--".
     */
    placeholder?: string;
    /**
     * An optional handler that will override this cell's default selection behavior. The registered handler will receive the `pointerup` event, the node data for the row this cell is associated with, and a reference to the parent `<vertex-scene-tree>` element for performing operations.
     */
    selectionHandler?: SceneTreeOperationHandler;
    /**
     * A reference to the scene tree to perform operations for interactions. Such as expansion, visibility and selection.
     */
    tree?: HTMLVertexSceneTreeElement;
    /**
     * The value to display in this cell.
     */
    value?: string;
    /**
     * An optional handler that will override this cell's default visibility behavior. The registered handler will receive the `pointerup` event, the node data for the row this cell is associated with, and a reference to the parent `<vertex-scene-tree>` element for performing operations.
     */
    visibilityHandler?: SceneTreeOperationHandler;
    /**
     * Indicates whether to display a button for toggling the visibility state of the node associated with this cell.
     */
    visibilityToggle?: boolean;
  }
  interface VertexSceneTreeTableColumn {
    /**
     * The initial width of this column.
     */
    initialWidth?: number;
    /**
     * The maximum width of this column.
     */
    maxWidth?: number;
    /**
     * The minimum width of this column.
     */
    minWidth?: number;
  }
  interface VertexSceneTreeTableHeader {}
  interface VertexSceneTreeTableLayout {
    controller?: SceneTreeController;
    layoutHeight?: number;
    layoutOffset?: number;
    layoutWidth?: number;
    onLayoutRendered?: (
      event: VertexSceneTreeTableLayoutCustomEvent<void>
    ) => void;
    /**
     * The number of offscreen rows above and below the viewport to render. Having a higher number reduces the chance of the browser not displaying a row while scrolling.  This prop will be automatically populated based on the `overScanCount` prop specified in the parent `<vertex-scene-tree />` element.
     */
    overScanCount?: number;
    /**
     * A callback that is invoked immediately before a row is about to rendered. This callback can return additional data that can be bound to in a template.  This prop will be automatically populated based on the `rowData` prop specified in the parent `<vertex-scene-tree />` element.
     * @example ```html <script>   const table = document.querySelector('vertex-scene-tree-table');   table.rowData = (row) => {     return { func: () => console.log('row', row.node.name) };   } </script>  <vertex-scene-tree>  <vertex-scene-tree-table>    <vertex-scene-tree-table-column>      <template>        <button event:click="{{row.data.func}}">Hi</button>      </template>    </vertex-scene-tree-table-column>  </vertex-scene-tree-table> </vertex-scene-tree> ```
     */
    rowData?: RowDataProvider;
    rowHeight?: number;
    rows?: Row[];
    scrollOffset?: number;
    totalRows?: number;
    /**
     * A reference to the scene tree to perform operations for interactions. Such as expansion, visibility and selection.
     */
    tree?: HTMLVertexSceneTreeElement;
    viewportEndIndex?: number;
    viewportStartIndex?: number;
  }
  interface VertexSceneTreeTableResizeDivider {}
  interface VertexSceneTreeToolbar {}
  interface VertexSceneTreeToolbarGroup {}
  interface VertexViewer {
    /**
     * Enables or disables the default mouse and touch interactions provided by the viewer. Enabled by default.
     */
    cameraControls?: boolean;
    /**
     * The type of camera model to represent the scene with. Can be either `perspective` or `orthographic`, and defaults to `perspective`.
     */
    cameraType?: FrameCameraType;
    /**
     * The Client ID associated with your Vertex Application.
     */
    clientId?: string;
    /**
     * An object or JSON encoded string that defines configuration settings for the viewer.
     */
    config?: PartialConfig | string;
    /**
     * Sets the default environment for the viewer. This setting is used for auto-configuring network hosts.  Use the `config` property for manually setting hosts.
     * @see Viewer.config
     */
    configEnv?: Environment;
    /**
     * Specifies when a depth buffer is requested from rendering. Possible values are:  * `undefined`: A depth buffer is never requested. * `final`: A depth buffer is only requested on the final frame. * `all`: A depth buffer is requested for every frame.  Depth buffers can increase the amount of data that's sent to a client and can impact rendering performance. Values of `undefined` or `final` should be used when needing the highest rendering performance.
     */
    depthBuffers?: FrameType;
    /**
     * Property used for internals or testing.
     * @private
     */
    deviceId?: string;
    /**
     * @private
     */
    experimentalRenderingOptions?: string;
    /**
     * Specifies how selected features should be highlighted.
     */
    featureHighlighting?: FeatureHighlightOptions;
    /**
     * Specifies if and how to render feature lines.
     */
    featureLines?: FeatureLineOptions;
    /**
     * Specifies when a feature map is returned from rendering. Feature maps include information about the surfaces, edges and cross sections that are in a frame.  Possible values are:  * `undefined`: A feature map is never requested. * `final`: A feature map is only requested on the final frame. * `all`: A feature map is requested for every frame.  Feature maps can increase the amount of data that's sent to a client and can impact rendering performance. Values of `undefined` or `final` should be used when needing the highest rendering performance.
     */
    featureMaps?: FrameType;
    /**
     * The last frame that was received, which can be used to inspect the scene and camera information.
     * @readonly
     */
    frame?: Frame | undefined;
    /**
     * Enables or disables the default keyboard shortcut interactions provided by the viewer. Enabled by default, requires `cameraControls` being enabled.
     */
    keyboardControls?: boolean;
    /**
     * Specifies whether to use the default lights for the scene. When false, default lights are used. When true, no default lights are used, and the lights must be specified separately.
     */
    noDefaultLights?: boolean;
    /**
     * Emits an event when the camera type changes.
     */
    onCameraTypeChanged?: (
      event: VertexViewerCustomEvent<FrameCameraType>
    ) => void;
    /**
     * Emits an event when the connection status changes for the viewer
     */
    onConnectionChange?: (
      event: VertexViewerCustomEvent<ConnectionStatus>
    ) => void;
    /**
     * Used for internals or testing.
     * @private
     */
    onDeviceIdChange?: (event: VertexViewerCustomEvent<string>) => void;
    onDimensionschange?: (
      event: VertexViewerCustomEvent<Dimensions.Dimensions>
    ) => void;
    /**
     * Emits an event whenever the user double taps or clicks a location in the viewer. The event includes the location of the first tap or click.
     */
    onDoubletap?: (event: VertexViewerCustomEvent<TapEventDetails>) => void;
    /**
     * Emits an event when a frame has been drawn to the viewer's canvas. The event will include details about the drawn frame, such as the `Scene` information related to the scene.
     */
    onFrameDrawn?: (event: VertexViewerCustomEvent<Frame>) => void;
    /**
     * Emits an event when a frame has been received by the viewer. The event will include details about the drawn frame, such as the `Scene` information related to the scene.
     */
    onFrameReceived?: (event: VertexViewerCustomEvent<Frame>) => void;
    /**
     * Emits an event when the user hs finished an interaction.
     */
    onInteractionFinished?: (event: VertexViewerCustomEvent<void>) => void;
    /**
     * Emits an event when the user has started an interaction.
     */
    onInteractionStarted?: (event: VertexViewerCustomEvent<void>) => void;
    /**
     * Emits an event whenever the user taps or clicks a location in the viewer and the configured amount of time passes without receiving a mouseup or touchend. The event includes the location of the tap or click.
     */
    onLongpress?: (event: VertexViewerCustomEvent<TapEventDetails>) => void;
    /**
     * Emits an event when a frame is received with a different scene attribute.
     */
    onSceneChanged?: (event: VertexViewerCustomEvent<void>) => void;
    /**
     * Emits an event when the scene is ready to be interacted with.
     */
    onSceneReady?: (event: VertexViewerCustomEvent<void>) => void;
    /**
     * Emits an event whenever the user taps or clicks a location in the viewer. The event includes the location of the tap or click.
     */
    onTap?: (event: VertexViewerCustomEvent<TapEventDetails>) => void;
    /**
     * Emits an event when a provided oauth2 token is about to expire, or is about to expire, causing issues with establishing a websocket connection, or performing API calls.
     */
    onTokenExpired?: (event: VertexViewerCustomEvent<void>) => void;
    /**
     * Specifies how phantom parts should appear. The opacity must be between 0 and 1, where 0 is completely hidden and 1 is completely visible.
     */
    phantom?: PhantomOptions;
    /**
     * An optional value that will debounce frame updates when resizing this viewer element.
     */
    resizeDebounce?: number;
    resolvedConfig?: Config;
    /**
     * Enables or disables the default rotation interaction being changed to rotate around the pointer down location.
     */
    rotateAroundTapPoint?: boolean;
    /**
     * Specifies the halo selection properties. Parameter notes:  lineWidth values supported currently are 0-5. This width is currently the value x2. For example, 1 will have a pixel width of 2.  color is optional. This will be the color of the selected items in the viewer.  opacity is also optional. The opacity will be applied to everything selected besides the highlighted outer line.
     */
    selectionHighlighting?: SelectionHighlightingOptions;
    /**
     * A URN of the scene resource to load when the component is mounted in the DOM tree. The specified resource is a URN in the following format:   * `urn:vertex:scene:<sceneid>`
     */
    src?: string;
    stencilBuffer?: StencilBufferManager;
    stream?: ViewerStream;
    /**
     * A token that can be used to make API calls to other Vertex services.
     */
    token?: string;
    /**
     * Represents the current viewport of the viewer. The viewport represents the dimensions of the canvas where a frame is rendered. It contains methods for translating between viewport coordinates, frame coordinates and world coordinates.
     */
    viewport?: Viewport;
  }
  interface VertexViewerBoxQueryTool {
    /**
     * The controller that is responsible for performing operations using the volume intersection query defined by the drawn box and updating the model.
     */
    controller?: VolumeIntersectionQueryController;
    /**
     * An optional value to specify a singular mode of intersection query. This value defaults to `undefined`, which will indicate that both `exclusive` and `inclusive` queries should be made, with `inclusive` being represented by a left to right drag behavior and `exclusive` being represented by a right to left drag.  Setting this value to `inclusive` will cause dragging left to right and left to right to result in an `inclusive` query, and the box will only be styled for `inclusive` queries.  Setting this value to `exclusive` will cause dragging left to right and left to right to result in an `exclusive` query, and the box will only be styled for `exclusive` queries.
     */
    mode?: VolumeIntersectionQueryMode;
    /**
     * The model that contains the points representing the corners of the box displayed on screen, the type of the query to be performed, and methods for setting these values.
     */
    model?: VolumeIntersectionQueryModel;
    /**
     * The default operation to perform when a drag has completed and the intersection query will be run. Defaults to `clearAndSelect`, and can be changed to `select` or `deselect`.  `clearAndSelect` will clear all existing selection, and select the results of the query. `select` will maintain existing selection, and select the results of the query. `deselect` will maintain existing selection, and deselect the results of the query.  The operation behavior for this intersection query tool can also be changed by providing a custom implementation of the `VolumeIntersectionQueryController`, or by using the `setOperationTransform` method of the default controller.
     */
    operationType?: VolumeIntersectionQueryType;
    /**
     * The viewer that this component is bound to. This is automatically assigned if added to the light-dom of a parent viewer element.
     */
    viewer?: HTMLVertexViewerElement;
  }
  interface VertexViewerButton {}
  interface VertexViewerDefaultToolbar {
    /**
     * The duration of animations, in milliseconds. Defaults to `1000`.
     */
    animationMs?: number;
    /**
     * Indicates whether animations will be used when performing camera operations. Defaults to `true`.
     */
    animationsDisabled?: boolean;
    /**
     * Specifies the direction that UI elements are placed.
     */
    direction?: ViewerToolbarGroupDirection;
    /**
     * Specifies where the toolbar is positioned.
     */
    placement?: ViewerToolbarPlacement;
    /**
     * An instance of the viewer that operations will be performed on. If contained within a `<vertex-viewer>` element, this property will automatically be wired.
     */
    viewer?: HTMLVertexViewerElement;
  }
  interface VertexViewerDomElement {
    /**
     * Disables the billboarding behavior of the element. When billboarding is enabled, the element will always be oriented towards the screen.
     */
    billboardOff?: boolean;
    /**
     * Disables interaction events from children.
     */
    interactionsOff?: boolean;
    /**
     * The local matrix of this element.
     */
    matrix?: Matrix4.Matrix4;
    /**
     * Indicates if the element is hidden by geometry. This property can be used with a CSS selector to modify the appearance of the element when its occluded.
     * @example ```html <style>   vertex-viewer-dom-element[occluded] {     opacity: 0;   } </style> ```
     */
    occluded?: boolean;
    /**
     * Disables occlusion testing for this element. Defaults to enabled. When enabled, the elements position will be tested against the current depth buffer. If the position is occluded, then the `occluded` attribute will be set.
     */
    occlusionOff?: boolean;
    /**
     * An event that is emitted when any property on the dom group changes
     */
    onPropertyChange?: (event: VertexViewerDomElementCustomEvent<void>) => void;
    /**
     * The local 3D position of where this element is located.
     */
    position?: Vector3.Vector3;
    /**
     * The local 3D position of where this element is located, as a JSON string. JSON representation can either be in the format of `[x, y, z]` or `{"x": 0, "y": 0, "z": 0}`.
     */
    positionJson?: string;
    /**
     * The local rotation of this element.
     */
    quaternion?: Quaternion.Quaternion;
    /**
     * The local quaternion rotation of this element, as a JSON string. JSON representation can either be `[x, y, z, w]` or `{"x": 0, "y": 0, "z": 0, "w": 1}`.
     */
    quaternionJson?: string;
    /**
     * The local rotation of this element in Euler angles.
     */
    rotation?: Euler.Euler;
    /**
     * The local rotation of this element in Euler angles, as a JSON string. JSON representation can either be `[x, y, z, order]` or `{"x": 0, "y": 0, "z": 0, "order": "xyz"}`.
     */
    rotationJson?: string;
    /**
     * The local scale of this element.
     */
    scale?: Vector3.Vector3;
    /**
     * The local scale of this element, as a JSON string. JSON string representation can either be in the format of `[x, y, z]` or `{"x": 0, "y": 0, "z": 0}`.
     */
    scaleJson?: string;
  }
  interface VertexViewerDomGroup {
    /**
     * The local matrix of this element.
     */
    matrix?: Matrix4.Matrix4;
    /**
     * An event that is emitted when any property on the dom group changes
     */
    onPropertyChange?: (event: VertexViewerDomGroupCustomEvent<void>) => void;
    /**
     * The local 3D position of where this element is located.
     */
    position?: Vector3.Vector3;
    /**
     * The local 3D position of where this element is located, as a JSON string. JSON representation can either be in the format of `[x, y, z]` or `{"x": 0, "y": 0, "z": 0}`.
     */
    positionJson?: string;
    /**
     * The local rotation of this element.
     */
    quaternion?: Quaternion.Quaternion;
    /**
     * The local rotation of this element, as a JSON string. JSON representation can either be `[x, y, z, w]` or `{"x": 0, "y": 0, "z": 0, "w": 1}`.
     */
    quaternionJson?: string;
    /**
     * The local rotation of this element in Euler angles.
     */
    rotation?: Euler.Euler;
    /**
     * The local rotation of this element in Euler angles, as a JSON string. JSON representation can either be `[x, y, z, order]` or `{"x": 0, "y": 0, "z": 0, "order": "xyz"}`.
     */
    rotationJson?: string;
    /**
     * The local scale of this element.
     */
    scale?: Vector3.Vector3;
    /**
     * The local scale of this element, as a JSON string. JSON string representation can either be in the format of `[x, y, z]` or `{"x": 0, "y": 0, "z": 0}`.
     */
    scaleJson?: string;
  }
  interface VertexViewerDomRenderer {
    /**
     * The current camera of the frame.  This property will automatically be set when supplying a viewer to the component, or when added as a child to `<vertex-viewer>`.
     */
    camera?: FrameCameraBase;
    /**
     * The current depth buffer of the frame.  This property will automatically be set when supplying a viewer to the component, or when added as a child to `<vertex-viewer>`.
     */
    depthBuffer?: DepthBuffer;
    /**
     * Specifies the drawing mode for the renderer.  When in `3d` mode, elements are positioned using CSS 3D transforms and will scale and rotate with the camera. In `2d` mode, a simpler 2D transform is used, and elements will not scale or rotate with camera changes.
     */
    drawMode?: ViewerDomRendererDrawMode;
    /**
     * The viewer synced to this renderer. This property will automatically be assigned if the renderer is a child of `<vertex-viewer>`.
     */
    viewer?: HTMLVertexViewerElement;
  }
  interface VertexViewerHitResultIndicator {
    /**
     * The normal of this indicator. This value will be represented as an arrow, and will be used alongside the provided `position` to display a plane.
     */
    normal?: Vector3.Vector3;
    /**
     * The position of this indicator. A point will be displayed at this position, and it will be used alongside the provided `normal` to display a plane and normal arrow centered at the position.
     */
    position?: Vector3.Vector3;
    /**
     * The viewer to connect to this indicator. If nested within a <vertex-viewer>, this property will be populated automatically.
     */
    viewer?: HTMLVertexViewerElement;
  }
  interface VertexViewerIcon {
    /**
     * The name of the icon to render.
     */
    name?: ViewerIconName;
    /**
     * The size of the icon. Can be `'sm' | 'md' | 'lg' | undefined`. Predefined sizes are set to:   * `sm`: 16px  * `md`: 24px  * `lg`: 32px  A custom size can be supplied by setting this field to `undefined` and setting `font-size` through CSS. Defaults to `md`.
     */
    size?: ViewerIconSize;
  }
  interface VertexViewerLayer {
    /**
     * Indicates if the layer should stretch to fill the size of its container's nearest positioned parent.
     */
    stretchOff?: boolean;
  }
  interface VertexViewerMarkup {
    /**
     * An HTML template that describes the HTML to use for new arrow markup. It's expected that the template contains a `<vertex-viewer-markup-arrow>`.
     */
    arrowTemplateId?: string;
    /**
     * An HTML template that describes the HTML to use for new circle markup. It's expected that the template contains a `<vertex-viewer-markup-circle>`.
     */
    circleTemplateId?: string;
    /**
     * If `true`, disables adding or editing of markup through user interaction.
     */
    disabled?: boolean;
    /**
     * An HTML template that describes the HTML to use for new freeform markup. It's expected that the template contains a `<vertex-viewer-markup-freeform>`.
     */
    freeformTemplateId?: string;
    /**
     * Dispatched when a new markup is added, either through user interaction or programmatically.
     */
    onMarkupAdded?: (
      event: VertexViewerMarkupCustomEvent<
        | HTMLVertexViewerMarkupArrowElement
        | HTMLVertexViewerMarkupCircleElement
        | HTMLVertexViewerMarkupFreeformElement
      >
    ) => void;
    /**
     * Dispatched when a markup is removed, either through user interaction or programmatically.
     */
    onMarkupRemoved?: (
      event: VertexViewerMarkupCustomEvent<
        | HTMLVertexViewerMarkupArrowElement
        | HTMLVertexViewerMarkupCircleElement
        | HTMLVertexViewerMarkupFreeformElement
      >
    ) => void;
    /**
     * Dispatched when markup selection changes. Will either be the selected element or `undefined` indicating that selection was cleared.
     */
    onMarkupSelectionChanged?: (
      event: VertexViewerMarkupCustomEvent<
        | HTMLVertexViewerMarkupArrowElement
        | HTMLVertexViewerMarkupCircleElement
        | HTMLVertexViewerMarkupFreeformElement
        | undefined
      >
    ) => void;
    /**
     * Indicates if new markup should be automatically selected.
     */
    selectNew?: boolean;
    /**
     * The ID of the markup that is selected.
     */
    selectedMarkupId?: string;
    /**
     * The type of markup to perform.
     */
    tool?: ViewerMarkupToolType;
    /**
     * The viewer to connect to markup. If nested within a <vertex-viewer>, this property will be populated automatically.
     */
    viewer?: HTMLVertexViewerElement;
  }
  interface VertexViewerMarkupArrow {
    /**
     * The position of the ending anchor. Can either be an instance of a `Point` or a JSON string representation in the format of `[x, y]` or `{"x": 0, "y": 0}`.  Points are expected to be relative coordinates from `[-0.5, 0.5]`, e.g. `[0, 0]` corresponds to a point in the center of the viewport.
     */
    end?: Point.Point;
    /**
     * The position of the ending anchor, as a JSON string. Can either be an instance of a `Point` or a JSON string representation in the format of `[x, y]` or `{"x": 0, "y": 0}`.  Points are expected to be relative coordinates from `[-0.5, 0.5]`, e.g. `[0, 0]` corresponds to a point in the center of the viewport.
     */
    endJson?: string;
    /**
     * A mode that specifies how the markup component should behave. When unset, the component will not respond to interactions with the handles. When `edit`, the markup anchors are interactive and the user is able to reposition them. When `create`, anytime the user clicks on the canvas, a new markup will be performed.
     */
    mode?: ViewerMarkupArrowMode;
    /**
     * An event that is dispatched anytime the user begins editing the markup.
     */
    onEditBegin?: (event: VertexViewerMarkupArrowCustomEvent<void>) => void;
    /**
     * An event that is dispatched when the user has finished editing the markup.
     */
    onEditEnd?: (event: VertexViewerMarkupArrowCustomEvent<void>) => void;
    /**
     * An event that is dispatched when this markup element is in view mode (`this.mode === ""`), and it completes a rerender.
     */
    onViewRendered?: (event: VertexViewerMarkupArrowCustomEvent<void>) => void;
    /**
     * The position of the starting anchor. Can either be an instance of a `Point` or a JSON string representation in the format of `[x, y]` or `{"x": 0, "y": 0}`.  Points are expected to be relative coordinates from `[-0.5, 0.5]`, e.g. `[0, 0]` corresponds to a point in the center of the viewport.
     */
    start?: Point.Point;
    /**
     * The position of the starting anchor, as a JSON string. Can either be an instance of a `Point` or a JSON string representation in the format of `[x, y]` or `{"x": 0, "y": 0}`.  Points are expected to be relative coordinates from `[-0.5, 0.5]`, e.g. `[0, 0]` corresponds to a point in the center of the viewport.
     */
    startJson?: string;
    /**
     * The viewer to connect to markups.  This property will automatically be set when a child of a `<vertex-viewer-markup>` or `<vertex-viewer>` element.
     */
    viewer?: HTMLVertexViewerElement;
  }
  interface VertexViewerMarkupCircle {
    /**
     * The bounds of the circle. Can either be an instance of a `Rectangle` or a JSON string representation in the format of `[x, y, width, height]` or `{"x": 0, "y": 0, "width": 10, "height": 10}`.  Bounds are expected to have relative coordinates, with `[x, y]` from `[-0.5, 0.5]` and `[width, height]` from `[0, 1]`, e.g. `[0, 0, 0.25, 0.25]`corresponds to a circle with a diameter of one fourth the viewport's smallest size in the center of the viewport.
     */
    bounds?: Rectangle.Rectangle;
    /**
     * The bounds of the circle. Can either be an instance of a `Rectangle` or a JSON string representation in the format of `[x, y, width, height]` or `{"x": 0, "y": 0, "width": 0.1, "height": 0.1}`.  Bounds are expected to have relative coordinates, with `[x, y]` from `[-0.5, 0.5]` and `[width, height]` from `[0, 1]`, e.g. `[0, 0, 0.25, 0.25]`corresponds to a circle with a diameter of one fourth the viewport's smallest size in the center of the viewport.
     */
    boundsJson?: string;
    /**
     * A mode that specifies how the markup component should behave. When unset, the component will not respond to interactions with the handles. When `edit`, the markup anchors are interactive and the user is able to reposition them. When `create`, anytime the user clicks on the canvas, a new markup will be performed.
     */
    mode?: ViewerMarkupCircleMode;
    /**
     * An event that is dispatched anytime the user begins editing the markup.
     */
    onEditBegin?: (event: VertexViewerMarkupCircleCustomEvent<void>) => void;
    /**
     * An event that is dispatched when the user has finished editing the markup.
     */
    onEditEnd?: (event: VertexViewerMarkupCircleCustomEvent<void>) => void;
    /**
     * An event that is dispatched when this markup element is in view mode (`this.mode === ""`), and it completes a rerender.
     */
    onViewRendered?: (event: VertexViewerMarkupCircleCustomEvent<void>) => void;
    /**
     * The viewer to connect to markups.  This property will automatically be set when a child of a `<vertex-viewer-markup>` or `<vertex-viewer>` element.
     */
    viewer?: HTMLVertexViewerElement;
  }
  interface VertexViewerMarkupFreeform {
    /**
     * The bounds of the freeform. Can either be an instance of a `Rectangle` or a JSON string representation in the format of `[x, y, width, height]` or `{"x": 0, "y": 0, "width": 10, "height": 10}`.  Bounds are expected to have relative coordinates, with `[x, y]` from `[-0.5, 0.5]` and `[width, height]` from `[0, 1]`, e.g. `[0, 0, 0.25, 0.25]`corresponds to a freeform with a diameter of one fourth the viewport's smallest size in the center of the viewport.
     */
    bounds?: Rectangle.Rectangle;
    /**
     * The bounds of the freeform. Can either be an instance of a `Rectangle` or a JSON string representation in the format of `[x, y, width, height]` or `{"x": 0, "y": 0, "width": 0.1, "height": 0.1}`.  Bounds are expected to have relative coordinates, with `[x, y]` from `[-0.5, 0.5]` and `[width, height]` from `[0, 1]`, e.g. `[0, 0, 0.25, 0.25]`corresponds to a freeform with a diameter of one fourth the viewport's smallest size in the center of the viewport.
     */
    boundsJson?: string;
    /**
     * A mode that specifies how the markup component should behave. When unset, the component will not respond to interactions with the handles. When `edit`, the markup anchors are interactive and the user is able to reposition them. When `create`, anytime the user clicks on the canvas, a new markup will be performed.
     */
    mode?: ViewerMarkupFreeformMode;
    /**
     * An event that is dispatched anytime the user begins editing the markup.
     */
    onEditBegin?: (event: VertexViewerMarkupFreeformCustomEvent<void>) => void;
    /**
     * An event that is dispatched when the user has finished editing the markup.
     */
    onEditEnd?: (event: VertexViewerMarkupFreeformCustomEvent<void>) => void;
    /**
     * An event that is dispatched when this markup element is in view mode (`this.mode === ""`), and it completes a rerender.
     */
    onViewRendered?: (
      event: VertexViewerMarkupFreeformCustomEvent<void>
    ) => void;
    /**
     * The positions of the various points of this freeform markup. Can either be an array of `Point`s or a JSON string representation in the format of `[[x1, y1], [x2, y2]]` or `[{"x": 0, "y": 0}, {"x": 0, "y": 0}]`.  Points are expected to be relative coordinates from `[-0.5, 0.5]`, e.g. `[0, 0]` corresponds to a point in the center of the viewport.
     */
    points?: Point.Point[];
    /**
     * The positions of the various points of this freeform markup. Can either be an array of `Point`s or a JSON string representation in the format of `[[x1, y1], [x2, y2]]` or `[{"x": 0, "y": 0}, {"x": 0, "y": 0}]`.  Points are expected to be relative coordinates from `[-0.5, 0.5]`, e.g. `[0, 0]` corresponds to a point in the center of the viewport.
     */
    pointsJson?: string;
    /**
     * The viewer to connect to markups.  This property will automatically be set when a child of a `<vertex-viewer-markup>` or `<vertex-viewer>` element.
     */
    viewer?: HTMLVertexViewerElement;
  }
  interface VertexViewerMarkupTool {
    /**
     * An HTML template that describes the HTML to use for new arrow markup. It's expected that the template contains a `<vertex-viewer-markup-arrow>`.
     */
    arrowTemplateId?: string;
    /**
     * An HTML template that describes the HTML to use for new circle markup. It's expected that the template contains a `<vertex-viewer-markup-circle>`.
     */
    circleTemplateId?: string;
    /**
     * Disables markups.  This property will automatically be set when a child of a `<vertex-viewer-markup>` element.
     */
    disabled?: boolean;
    /**
     * An HTML template that describes the HTML to use for new freeform markup. It's expected that the template contains a `<vertex-viewer-markup-freeform>`.
     */
    freeformTemplateId?: string;
    /**
     * An event that is dispatched when a user begins a new markup.
     */
    onMarkupBegin?: (event: VertexViewerMarkupToolCustomEvent<void>) => void;
    /**
     * An event that is dispatched when a user has finished their markup.
     */
    onMarkupEnd?: (event: VertexViewerMarkupToolCustomEvent<Markup>) => void;
    /**
     * The type of markup.  This property will automatically be set when a child of a `<vertex-viewer-markup>` element.
     */
    tool?: ViewerMarkupToolType;
    /**
     * The viewer to connect to markup.  This property will automatically be set when a child of a `<vertex-viewer-markup>` or `<vertex-viewer>` element.
     */
    viewer?: HTMLVertexViewerElement;
  }
  interface VertexViewerMeasurementDetails {
    /**
     * An optional formatter that can be used to format the display of an angle. The formatting function is passed a calculated angle in degrees and is expected to return a string.
     */
    angleFormatter?: Formatter<number>;
    /**
     * The unit of angle-based measurement.
     */
    angleUnits?: AngleUnitType;
    /**
     * An optional formatter that can be used to format the display of an area. The formatting function is passed a calculated area and is expected to return a string.
     */
    areaFormatter?: Formatter<number>;
    /**
     * An optional formatter that can be used to format the display of a distance. The formatting function is passed a calculated real-world distance and is expected to return a string.
     */
    distanceFormatter?: Formatter<number>;
    /**
     * The unit of distance-based measurement.
     */
    distanceUnits?: DistanceUnitType;
    /**
     * The number of fraction digits to display.
     */
    fractionalDigits?: number;
    /**
     * The `MeasurementModel` that should be reflected in these details. If not specified, a new `MeasurementModel` will be created, which can then be used to update the display.
     */
    measurementModel?: MeasurementModel;
    /**
     * The outcome to display. This property is automatically updated if a measurement model is provided.
     */
    measurementOutcome?: MeasurementOutcome;
    /**
     * The manager that the component will use to present measurement overlays.
     */
    measurementOverlays?: MeasurementOverlayManager;
    /**
     * A set of result types to display. If `undefined`, then all results will be displayed.
     */
    resultTypes?: MeasurementResult['type'][];
  }
  interface VertexViewerMeasurementDistance {
    /**
     * The distance from an anchor to its label.
     */
    anchorLabelOffset?: number;
    /**
     * The camera used to position the anchors. If `viewer` is defined, then the projection view matrix of the viewer will be used.
     */
    camera?: FrameCameraBase1;
    /**
     * The distance between `start` and `end` in real world units. Value will be undefined if the start and end positions are undefined, or if the measurement is invalid.
     */
    distance?: number;
    /**
     * The world position of the ending anchor.
     */
    end?: Vector3.Vector3;
    /**
     * The world position of the ending anchor, as a JSON string. The JSON string can be an array or object representation in the format of `[x, y, z]` or `{"x": 0, "y": 0, "z": 0}`.
     */
    endJson?: string;
    /**
     * The number of fraction digits to display.
     */
    fractionalDigits?: number;
    hitProvider?: PointToPointHitProvider;
    indicatorPt?: Vector3.Vector3;
    /**
     * A property that reflects which anchor is currently being interacted with.
     */
    interactingAnchor?: Anchor | 'none';
    /**
     * Indicates if the measurement is invalid. A measurement is invalid if either the start or end position are not on the surface of the model.
     */
    invalid?: boolean;
    /**
     * An optional formatter that can be used to format the display of a distance. The formatting function is passed a calculated real-world distance and is expected to return a string.
     */
    labelFormatter?: Formatter<number | undefined>;
    /**
     * The length of the caps at each end of the distance measurement.
     */
    lineCapLength?: number;
    /**
     * The measurement model that will be updated when this measurement changes. You can pass this to a <vertex-viewer-measurement-details> component to display measurement outcomes.
     */
    measurementModel?: MeasurementModel;
    /**
     * A mode that specifies how the measurement component should behave.  When unset, the component will not respond to interactions with the handles.  When `edit`, the measurement anchors are interactive and the user is able to reposition them.  When `replace`, anytime the user clicks on the canvas, a new measurement will be created and replace any existing measurement. After a measurement is created, the measurement will be editable.
     */
    mode?: ViewerMeasurementDistanceMode;
    /**
     * An event that is dispatched anytime the user begins editing the measurement.
     */
    onEditBegin?: (
      event: VertexViewerMeasurementDistanceCustomEvent<EditBeginEventDetails>
    ) => void;
    /**
     * An event that is dispatched when the user has finished editing the measurement.
     */
    onEditEnd?: (
      event: VertexViewerMeasurementDistanceCustomEvent<EditEndEventDetails>
    ) => void;
    /**
     * Enables the display of axis reference lines between the start and end point.
     */
    showAxisReferenceLines?: boolean;
    /**
     * The distance, in pixels, between the mouse and nearest snappable edge. A value of 0 disables snapping.
     */
    snapDistance?: number;
    /**
     * The world position of the starting anchor.
     */
    start?: Vector3.Vector3;
    /**
     * The world position of the starting anchor, as a JSON string. The JSON string can be an array or object representation in the format of `[x, y, z]` or `{"x": 0, "y": 0, "z": 0}`.
     */
    startJson?: string;
    /**
     * The unit of measurement.
     */
    units?: DistanceUnitType;
    /**
     * The viewer to connect to this measurement. The measurement will redraw any time the viewer redraws the scene.
     */
    viewer?: HTMLVertexViewerElement;
  }
  interface VertexViewerMeasurementLine {
    /**
     * A length of the line cap. The line cap is a line at each end of a line.
     */
    capLength?: number;
    /**
     * A point that specifies the ending point of the line.
     */
    end?: Point.Point;
    /**
     * The type of [SVG pointer events](https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/pointer-events) that the line should respond to.
     */
    pointerEvents?: string;
    /**
     * A point that specifies the starting point of the line.
     */
    start?: Point.Point;
  }
  interface VertexViewerMeasurementOverlays {
    camera?: FrameCameraBase1;
    /**
     * The model that contains the overlays to present.
     */
    measurementOverlays?: MeasurementOverlayManager;
    /**
     * The viewer that this component is bound to.
     */
    viewer?: HTMLVertexViewerElement;
  }
  interface VertexViewerMeasurementPrecise {
    /**
     * An optional configuration to setup network configuration of measurement endpoints.
     */
    config?: PartialConfig | string;
    /**
     * The environment that will be used to request measurement results.
     */
    configEnv?: Environment;
    measurableEntityTypes?: EntityType[];
    /**
     * The controller that is responsible for performing measurements and updating the model.
     */
    measurementController?: MeasurementController;
    /**
     * The model that contains the entities and outcomes from performing precise measurements.
     */
    measurementModel?: MeasurementModel;
    /**
     * The manager that is responsible for measurement overlays to present by this component.
     */
    measurementOverlays?: MeasurementOverlayManager;
    /**
     * The viewer that this component is bound to. This is automatically assigned if added to the light-dom of a parent viewer element.
     */
    viewer?: HTMLVertexViewerElement;
  }
  interface VertexViewerPinGroup {
    /**
     * The dimensions of the canvas for the pins
     */
    elementBounds?: DOMRect;
    /**
     * The local matrix of this element.
     */
    matrix?: Matrix4.Matrix4;
    /**
     * The pin to draw for the group
     */
    pin?: Pin;
    /**
     * The controller that drives behavior for pin operations
     */
    pinController?: PinController;
    /**
     * The model that contains the entities and outcomes from performing pin operations
     */
    pinModel?: PinModel;
    /**
     * Projection view matrix used for computing the position of the pin line
     */
    projectionViewMatrix?: Matrix4.Matrix4;
    /**
     * Whether or not the pin is "selected"
     */
    selected?: boolean;
  }
  interface VertexViewerPinLabel {
    /**
     * The dimensions of the canvas for the pins
     */
    elementBounds?: DOMRect;
    /**
     * Emitted whenever the label is blurred, with the ID of the associated pin (or undefined if no pin is provided).
     */
    onLabelBlurred?: (
      event: VertexViewerPinLabelCustomEvent<string | undefined>
    ) => void;
    onLabelChanged?: (event: VertexViewerPinLabelCustomEvent<void>) => void;
    /**
     * Emitted whenever the label is focused, with the ID of the associated pin (or undefined if no pin is provided).
     */
    onLabelFocused?: (
      event: VertexViewerPinLabelCustomEvent<string | undefined>
    ) => void;
    /**
     * The pin to draw for the group
     */
    pin?: TextPin;
    /**
     * The controller that drives behavior for pin operations
     */
    pinController?: PinController;
    /**
     * The current text value of the component. Value is updated on user interaction.
     */
    value?: string;
  }
  interface VertexViewerPinLabelLine {
    labelPoint?: Point.Point | undefined;
    pin?: Pin | undefined;
    pinPoint?: Point.Point | undefined;
  }
  interface VertexViewerPinTool {
    /**
     * The accent color for new pins. Setting this will override the accent template color, and will be used for any new pins created with this `vertex-viewer-pin-tool`. This styling applies to some background colors, etc
     */
    accentColor?: Color.Color | string | undefined;
    /**
     * The mode of the pin tool
     */
    mode?: ViewerPinToolMode;
    /**
     * The controller that is responsible for drawing pins and updating the model
     */
    pinController?: PinController;
    /**
     * The model that contains the entities and outcomes from performing pin annotations
     */
    pinModel?: PinModel;
    /**
     * The primary color for new pins. Setting this will override the primary template color, and will be used for any new pins created with this `vertex-viewer-pin-tool`. This styling applies to pin anchors, and borders, etc.
     */
    primaryColor?: Color.Color | string | undefined;
    /**
     * The type of pin.  This property will automatically be set.
     */
    tool?: ViewerPinToolType;
    /**
     * The viewer that this component is bound to. This is automatically assigned if added to the light-dom of a parent viewer element.
     */
    viewer?: HTMLVertexViewerElement;
  }
  interface VertexViewerSpinner {
    /**
     * The size of the spinner. Can be `'xs' | 'sm' | 'md' | 'lg' | undefined`. Predefined sizes are set to:   * `xm`: 16px  * `sm`: 24px  * `md`: 32px  * `lg`: 64px
     */
    size?: SpinnerSize;
  }
  interface VertexViewerTeleportTool {
    /**
     * The duration of animations, in milliseconds. Defaults to `500`.
     */
    animationMs?: number;
    /**
     * Indicates whether animations will be used when performing camera operations. Defaults to `false`.
     */
    animationsDisabled?: boolean;
    controller?: WalkModeController;
    /**
     * The type of teleportation to perform when clicking.  `teleport` - the camera's `position` is moved to the location of the hit result constrained by the plane represented by the camera's current `position` and `up` vectors.  `teleport-and-align` - the camera's `position`, `lookAt`, and `up` vectors are updated to align to the plane represented by the hit result's position and normal.  `teleport-toward` - the camera's `position` is moved a fixed distance toward the location of the hit result constrained by the plane represented by the camera's current `position` and `up` vectors.  `undefined` - no teleportation will occur when clicking.  Defaults to `undefined`.
     */
    mode?: ViewerTeleportMode;
    model?: WalkModeModel;
    /**
     * Event emitted when the `WalkModeController` associated with this tool changes.
     */
    onControllerChanged?: (
      event: VertexViewerTeleportToolCustomEvent<WalkModeController>
    ) => void;
    /**
     * The viewer that this component is bound to. This is automatically assigned if added to the light-dom of a parent viewer element.
     */
    viewer?: HTMLVertexViewerElement;
  }
  interface VertexViewerToolbar {
    direction?: ViewerToolbarDirection;
    /**
     * Specifies where the toolbar is positioned.
     */
    placement?: ViewerToolbarPlacement;
  }
  interface VertexViewerToolbarGroup {
    direction?: ViewerToolbarGroupDirection;
  }
  interface VertexViewerTransformWidget {
    /**
     * The controller that is responsible for performing transforms.
     */
    controller?: TransformController;
    /**
     * @ignore Visible for testing.
     */
    hovered?: Drawable;
    /**
     * An event that is emitted when the interaction has ended
     */
    onInteractionEnded?: (
      event: VertexViewerTransformWidgetCustomEvent<Matrix4.Matrix4 | undefined>
    ) => void;
    /**
     * An event that is emitted an interaction with the widget has started
     */
    onInteractionStarted?: (
      event: VertexViewerTransformWidgetCustomEvent<void>
    ) => void;
    /**
     * An event that is emitted when the position of the widget changes.
     */
    onPositionChanged?: (
      event: VertexViewerTransformWidgetCustomEvent<Vector3.Vector3 | undefined>
    ) => void;
    /**
     * An event that is emitted when the rotation of the widget changes.
     */
    onRotationChanged?: (
      event: VertexViewerTransformWidgetCustomEvent<Euler.Euler | undefined>
    ) => void;
    /**
     * The starting position of this transform widget. This position will be updated as transforms occur. Setting this value to `undefined` will remove the widget.
     */
    position?: Vector3.Vector3;
    /**
     * The starting angle for the transform widget. This rotation will be updated as the rotations occur.
     */
    rotation?: Euler.Euler;
    /**
     * The viewer to connect to transforms. If nested within a <vertex-viewer>, this property will be populated automatically.
     */
    viewer?: HTMLVertexViewerElement;
    /**
     * Determines whether or not the x-rotation is disabled on the widget
     */
    xRotationDisabled?: boolean;
    /**
     * Determines whether or not the x-translation is disabled on the widget
     */
    xTranslationDisabled?: boolean;
    /**
     * Determines whether or not the y-rotation is disabled on the widget
     */
    yRotationDisabled?: boolean;
    /**
     * Determines whether or not the y-translation is disabled on the widget
     */
    yTranslationDisabled?: boolean;
    /**
     * Determines whether or not the z-rotation is disabled on the widget
     */
    zRotationDisabled?: boolean;
    /**
     * Determines whether or not the z-translation is disabled on the widget
     */
    zTranslationDisabled?: boolean;
  }
  interface VertexViewerViewCube {
    /**
     * The duration of the animation, in milliseconds, when a user performs a standard view interaction. Set to 0 to disable animations.
     */
    animationDuration?: number;
    camera?: FramePerspectiveCamera;
    /**
     * Disables interactions for standard views.
     */
    standardViewsOff?: boolean;
    /**
     * Disables the display of the triad.
     */
    triadOff?: boolean;
    /**
     * The viewer element that is connected to the view cube.
     */
    viewer?: HTMLVertexViewerElement;
    worldOrientation?: Orientation;
    /**
     * The label for the side of the cube on the negative x-axis.
     */
    xNegativeLabel?: string;
    /**
     * The label for the side of the cube on the positive x-axis.
     */
    xPositiveLabel?: string;
    /**
     * The label for the side of the cube on the negative y-axis.
     */
    yNegativeLabel?: string;
    /**
     * The label for the side of the cube on the positive y-axis.
     */
    yPositiveLabel?: string;
    /**
     * The label for the side of the cube on the negative z-axis.
     */
    zNegativeLabel?: string;
    /**
     * The label for the side of the cube on the positive z-axis.
     */
    zPositiveLabel?: string;
  }
  interface VertexViewerWalkModeTool {
    /**
     * The `WalkModeController` responsible for controlling `KeyBinding`s and excluded elements, as well as updating the `WalkModeModel` with various configuration settings.
     */
    controller?: WalkModeController;
    /**
     * Determines whether the interaction handlers for this tool should respond to events. When set to `true`, the default viewer interaction mode will be overridden to use the `pivot` camera interaction type, keyboard controls for movement will be added, and setting the `teleportMode` will enable the tool.  Defaults to `true`.
     */
    enabled?: boolean;
    /**
     * The `WalkModeModel` responsible for tracking configuration and emitting events for interaction handlers to respond to.
     */
    model?: WalkModeModel;
    /**
     * Event emitted when the `WalkModeController` associated with this tool changes.
     */
    onControllerChanged?: (
      event: VertexViewerWalkModeToolCustomEvent<WalkModeController>
    ) => void;
    /**
     * The type of teleportation to perform when clicking. This value is passed through to a `<vertex-viewer-teleport-tool>`'s mode attribute.  `teleport` - the camera's `position` is moved to the location of the hit result constrained by the plane represented by the camera's current `position` and `up` vectors.  `teleport-and-align` - the camera's `position`, `lookAt`, and `up` vectors are updated to align to the plane represented by the hit result's position and normal.  `teleport-toward` - the camera's `position` is moved a fixed distance toward the location of the hit result constrained by the plane represented by the camera's current `position` and `up` vectors.  `undefined` - no teleportation will occur when clicking.  Defaults to `undefined`.
     */
    teleportMode?: ViewerTeleportMode;
    /**
     * The viewer that this component is bound to. This is automatically assigned if added to the light-dom of a parent viewer element.
     */
    viewer?: HTMLVertexViewerElement;
  }
  interface IntrinsicElements {
    'vertex-scene-tree': VertexSceneTree;
    'vertex-scene-tree-search': VertexSceneTreeSearch;
    'vertex-scene-tree-table-cell': VertexSceneTreeTableCell;
    'vertex-scene-tree-table-column': VertexSceneTreeTableColumn;
    'vertex-scene-tree-table-header': VertexSceneTreeTableHeader;
    'vertex-scene-tree-table-layout': VertexSceneTreeTableLayout;
    'vertex-scene-tree-table-resize-divider': VertexSceneTreeTableResizeDivider;
    'vertex-scene-tree-toolbar': VertexSceneTreeToolbar;
    'vertex-scene-tree-toolbar-group': VertexSceneTreeToolbarGroup;
    'vertex-viewer': VertexViewer;
    'vertex-viewer-box-query-tool': VertexViewerBoxQueryTool;
    'vertex-viewer-button': VertexViewerButton;
    'vertex-viewer-default-toolbar': VertexViewerDefaultToolbar;
    'vertex-viewer-dom-element': VertexViewerDomElement;
    'vertex-viewer-dom-group': VertexViewerDomGroup;
    'vertex-viewer-dom-renderer': VertexViewerDomRenderer;
    'vertex-viewer-hit-result-indicator': VertexViewerHitResultIndicator;
    'vertex-viewer-icon': VertexViewerIcon;
    'vertex-viewer-layer': VertexViewerLayer;
    'vertex-viewer-markup': VertexViewerMarkup;
    'vertex-viewer-markup-arrow': VertexViewerMarkupArrow;
    'vertex-viewer-markup-circle': VertexViewerMarkupCircle;
    'vertex-viewer-markup-freeform': VertexViewerMarkupFreeform;
    'vertex-viewer-markup-tool': VertexViewerMarkupTool;
    'vertex-viewer-measurement-details': VertexViewerMeasurementDetails;
    'vertex-viewer-measurement-distance': VertexViewerMeasurementDistance;
    'vertex-viewer-measurement-line': VertexViewerMeasurementLine;
    'vertex-viewer-measurement-overlays': VertexViewerMeasurementOverlays;
    'vertex-viewer-measurement-precise': VertexViewerMeasurementPrecise;
    'vertex-viewer-pin-group': VertexViewerPinGroup;
    'vertex-viewer-pin-label': VertexViewerPinLabel;
    'vertex-viewer-pin-label-line': VertexViewerPinLabelLine;
    'vertex-viewer-pin-tool': VertexViewerPinTool;
    'vertex-viewer-spinner': VertexViewerSpinner;
    'vertex-viewer-teleport-tool': VertexViewerTeleportTool;
    'vertex-viewer-toolbar': VertexViewerToolbar;
    'vertex-viewer-toolbar-group': VertexViewerToolbarGroup;
    'vertex-viewer-transform-widget': VertexViewerTransformWidget;
    'vertex-viewer-view-cube': VertexViewerViewCube;
    'vertex-viewer-walk-mode-tool': VertexViewerWalkModeTool;
  }
}
export { LocalJSX as JSX };
declare module '@stencil/core' {
  export namespace JSX {
    interface IntrinsicElements {
      'vertex-scene-tree': LocalJSX.VertexSceneTree &
        JSXBase.HTMLAttributes<HTMLVertexSceneTreeElement>;
      'vertex-scene-tree-search': LocalJSX.VertexSceneTreeSearch &
        JSXBase.HTMLAttributes<HTMLVertexSceneTreeSearchElement>;
      'vertex-scene-tree-table-cell': LocalJSX.VertexSceneTreeTableCell &
        JSXBase.HTMLAttributes<HTMLVertexSceneTreeTableCellElement>;
      'vertex-scene-tree-table-column': LocalJSX.VertexSceneTreeTableColumn &
        JSXBase.HTMLAttributes<HTMLVertexSceneTreeTableColumnElement>;
      'vertex-scene-tree-table-header': LocalJSX.VertexSceneTreeTableHeader &
        JSXBase.HTMLAttributes<HTMLVertexSceneTreeTableHeaderElement>;
      'vertex-scene-tree-table-layout': LocalJSX.VertexSceneTreeTableLayout &
        JSXBase.HTMLAttributes<HTMLVertexSceneTreeTableLayoutElement>;
      'vertex-scene-tree-table-resize-divider': LocalJSX.VertexSceneTreeTableResizeDivider &
        JSXBase.HTMLAttributes<HTMLVertexSceneTreeTableResizeDividerElement>;
      'vertex-scene-tree-toolbar': LocalJSX.VertexSceneTreeToolbar &
        JSXBase.HTMLAttributes<HTMLVertexSceneTreeToolbarElement>;
      'vertex-scene-tree-toolbar-group': LocalJSX.VertexSceneTreeToolbarGroup &
        JSXBase.HTMLAttributes<HTMLVertexSceneTreeToolbarGroupElement>;
      'vertex-viewer': LocalJSX.VertexViewer &
        JSXBase.HTMLAttributes<HTMLVertexViewerElement>;
      'vertex-viewer-box-query-tool': LocalJSX.VertexViewerBoxQueryTool &
        JSXBase.HTMLAttributes<HTMLVertexViewerBoxQueryToolElement>;
      'vertex-viewer-button': LocalJSX.VertexViewerButton &
        JSXBase.HTMLAttributes<HTMLVertexViewerButtonElement>;
      'vertex-viewer-default-toolbar': LocalJSX.VertexViewerDefaultToolbar &
        JSXBase.HTMLAttributes<HTMLVertexViewerDefaultToolbarElement>;
      'vertex-viewer-dom-element': LocalJSX.VertexViewerDomElement &
        JSXBase.HTMLAttributes<HTMLVertexViewerDomElementElement>;
      'vertex-viewer-dom-group': LocalJSX.VertexViewerDomGroup &
        JSXBase.HTMLAttributes<HTMLVertexViewerDomGroupElement>;
      'vertex-viewer-dom-renderer': LocalJSX.VertexViewerDomRenderer &
        JSXBase.HTMLAttributes<HTMLVertexViewerDomRendererElement>;
      'vertex-viewer-hit-result-indicator': LocalJSX.VertexViewerHitResultIndicator &
        JSXBase.HTMLAttributes<HTMLVertexViewerHitResultIndicatorElement>;
      'vertex-viewer-icon': LocalJSX.VertexViewerIcon &
        JSXBase.HTMLAttributes<HTMLVertexViewerIconElement>;
      'vertex-viewer-layer': LocalJSX.VertexViewerLayer &
        JSXBase.HTMLAttributes<HTMLVertexViewerLayerElement>;
      'vertex-viewer-markup': LocalJSX.VertexViewerMarkup &
        JSXBase.HTMLAttributes<HTMLVertexViewerMarkupElement>;
      'vertex-viewer-markup-arrow': LocalJSX.VertexViewerMarkupArrow &
        JSXBase.HTMLAttributes<HTMLVertexViewerMarkupArrowElement>;
      'vertex-viewer-markup-circle': LocalJSX.VertexViewerMarkupCircle &
        JSXBase.HTMLAttributes<HTMLVertexViewerMarkupCircleElement>;
      'vertex-viewer-markup-freeform': LocalJSX.VertexViewerMarkupFreeform &
        JSXBase.HTMLAttributes<HTMLVertexViewerMarkupFreeformElement>;
      'vertex-viewer-markup-tool': LocalJSX.VertexViewerMarkupTool &
        JSXBase.HTMLAttributes<HTMLVertexViewerMarkupToolElement>;
      'vertex-viewer-measurement-details': LocalJSX.VertexViewerMeasurementDetails &
        JSXBase.HTMLAttributes<HTMLVertexViewerMeasurementDetailsElement>;
      'vertex-viewer-measurement-distance': LocalJSX.VertexViewerMeasurementDistance &
        JSXBase.HTMLAttributes<HTMLVertexViewerMeasurementDistanceElement>;
      'vertex-viewer-measurement-line': LocalJSX.VertexViewerMeasurementLine &
        JSXBase.HTMLAttributes<HTMLVertexViewerMeasurementLineElement>;
      'vertex-viewer-measurement-overlays': LocalJSX.VertexViewerMeasurementOverlays &
        JSXBase.HTMLAttributes<HTMLVertexViewerMeasurementOverlaysElement>;
      'vertex-viewer-measurement-precise': LocalJSX.VertexViewerMeasurementPrecise &
        JSXBase.HTMLAttributes<HTMLVertexViewerMeasurementPreciseElement>;
      'vertex-viewer-pin-group': LocalJSX.VertexViewerPinGroup &
        JSXBase.HTMLAttributes<HTMLVertexViewerPinGroupElement>;
      'vertex-viewer-pin-label': LocalJSX.VertexViewerPinLabel &
        JSXBase.HTMLAttributes<HTMLVertexViewerPinLabelElement>;
      'vertex-viewer-pin-label-line': LocalJSX.VertexViewerPinLabelLine &
        JSXBase.HTMLAttributes<HTMLVertexViewerPinLabelLineElement>;
      'vertex-viewer-pin-tool': LocalJSX.VertexViewerPinTool &
        JSXBase.HTMLAttributes<HTMLVertexViewerPinToolElement>;
      'vertex-viewer-spinner': LocalJSX.VertexViewerSpinner &
        JSXBase.HTMLAttributes<HTMLVertexViewerSpinnerElement>;
      'vertex-viewer-teleport-tool': LocalJSX.VertexViewerTeleportTool &
        JSXBase.HTMLAttributes<HTMLVertexViewerTeleportToolElement>;
      'vertex-viewer-toolbar': LocalJSX.VertexViewerToolbar &
        JSXBase.HTMLAttributes<HTMLVertexViewerToolbarElement>;
      'vertex-viewer-toolbar-group': LocalJSX.VertexViewerToolbarGroup &
        JSXBase.HTMLAttributes<HTMLVertexViewerToolbarGroupElement>;
      'vertex-viewer-transform-widget': LocalJSX.VertexViewerTransformWidget &
        JSXBase.HTMLAttributes<HTMLVertexViewerTransformWidgetElement>;
      'vertex-viewer-view-cube': LocalJSX.VertexViewerViewCube &
        JSXBase.HTMLAttributes<HTMLVertexViewerViewCubeElement>;
      'vertex-viewer-walk-mode-tool': LocalJSX.VertexViewerWalkModeTool &
        JSXBase.HTMLAttributes<HTMLVertexViewerWalkModeToolElement>;
    }
  }
}
