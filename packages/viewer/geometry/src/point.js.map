{"version":3,"file":"point.js","sourceRoot":"","sources":["../../../../geometry/src/point.ts"],"names":[],"mappings":"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","sourcesContent":["import * as Angle from './angle';\nimport { lerp as lerpNumber } from './math';\n\n/**\n * A `Point` represents a cartesian coordinate with a horizontal and vertical\n * position or length.\n */\nexport interface Point {\n  x: number;\n  y: number;\n}\n\n/**\n * Returns a new `Point` with the given horizontal and vertical position.\n */\nexport function create(x = 0, y = 0): Point {\n  return { x, y };\n}\n\n/**\n * Converts a polar coordinate (length and angle) into a Cartesian coordinate.\n */\nexport function polar(length: number, radians: Angle.Angle): Point {\n  const x = Math.cos(radians) * length;\n  const y = Math.sin(radians) * length;\n  return create(x, y);\n}\n\n/**\n * Returns the distance between two points.\n */\nexport function distance(a: Point, b: Point): number {\n  const delta = subtract(a, b);\n  return Math.sqrt(delta.x * delta.x + delta.y * delta.y);\n}\n\n/**\n * Returns a new `Point` where `b` is subtracted from `a`.\n */\nexport function subtract(a: Point, b: Point): Point {\n  return { x: a.x - b.x, y: a.y - b.y };\n}\n\n/**\n * Returns a new `Point` where `b` is added to `a`.\n */\nexport function add(a: Point, b: Point): Point {\n  return { x: a.x + b.x, y: a.y + b.y };\n}\n\n/**\n * Returns `true` if the `x` and `y` positions of `a` and `b` are equal.\n */\nexport function isEqual(a: Point, b: Point): boolean {\n  return a.x === b.x && a.y === b.y;\n}\n\n/**\n * Performs a linear interpolation between `a` and `b` and returns the result.\n * The value of `t` is clamped between `[0, 1]`.\n *\n * @param a The start value.\n * @param b The end value.\n * @param t A value between 0 and 1.\n * @returns A point between `a` and `b`.\n */\nexport function lerp(a: Point, b: Point, t: number): Point {\n  return {\n    x: lerpNumber(a.x, b.x, t),\n    y: lerpNumber(a.y, b.y, t),\n  };\n}\n\n/**\n * Returns a new `Point` where `x` and `y` are inverted.\n */\nexport function negate(pt: Point): Point {\n  return create(-pt.x, -pt.y);\n}\n\n/**\n * Returns a new `Point` where `x` and `y` are multiplied by the given scale\n * factors.\n */\nexport function scale(pt: Point, scaleX: number, scaleY: number): Point {\n  return {\n    x: pt.x * scaleX,\n    y: pt.y * scaleY,\n  };\n}\n\n/**\n * Returns a new `Point` where `x` and `y` are multiplied by the given scale\n * factor.\n */\nexport function scaleProportional(pt: Point, scale: number): Point {\n  return {\n    x: pt.x * scale,\n    y: pt.y * scale,\n  };\n}\n\n/**\n * Returns the magnitude of a point.\n */\nexport function magnitude(pt: Point): number {\n  return Math.sqrt(pt.x * pt.x + pt.y * pt.y);\n}\n\n/**\n * Transforms a vector into the corresponding normal (unit) vector.\n */\nexport function normalizeVector(pt: Point): Point {\n  const magnitudeOfPoint = magnitude(pt);\n  if (magnitudeOfPoint === 0) {\n    return create(0, 0);\n  } else {\n    return scaleProportional(pt, 1 / magnitudeOfPoint);\n  }\n}\n\n/**\n * Returns a new normal (unit) vector pointing between the two given points.\n */\nexport function normalDirectionVector(ptA: Point, ptB: Point): Point {\n  return normalizeVector(subtract(ptB, ptA));\n}\n\n/**\n * Returns a vector orthogonal to the vector between the two given points.\n */\nexport function orthogonalVector(ptA: Point, ptB: Point): Point {\n  const unitVectorBetweenPoints = normalDirectionVector(ptA, ptB);\n\n  // Handle vectors that are parallel to the x or y axis\n  if (unitVectorBetweenPoints.x === 0 || unitVectorBetweenPoints.y === 0) {\n    return create(-1 * unitVectorBetweenPoints.y, unitVectorBetweenPoints.x);\n  }\n\n  if (\n    Math.abs(unitVectorBetweenPoints.x) > Math.abs(unitVectorBetweenPoints.y)\n  ) {\n    const vectorXValue = 1 - Math.pow(unitVectorBetweenPoints.x, 2);\n    const vectorYValue =\n      -1 * unitVectorBetweenPoints.x * unitVectorBetweenPoints.y;\n    return normalizeVector(create(vectorXValue, vectorYValue));\n  } else {\n    const vectorXValue =\n      -1 * unitVectorBetweenPoints.x * unitVectorBetweenPoints.y;\n    const vectorYValue = 1 - Math.pow(unitVectorBetweenPoints.y, 2);\n    return normalizeVector(create(vectorXValue, vectorYValue));\n  }\n}\n\n/**\n * Parses a JSON string representation of a Point and returns an object.\n *\n * @param json A JSON string, either in the form `[x,y]` or `{\"x\": 0, \"y\": 0}`\n * @returns A parsed Point.\n */\nexport function fromJson(json: string): Point {\n  const obj = JSON.parse(json);\n  if (Array.isArray(obj)) {\n    const [x, y] = obj;\n    return create(x, y);\n  } else {\n    const { x, y } = obj;\n    return create(x, y);\n  }\n}\n"]}